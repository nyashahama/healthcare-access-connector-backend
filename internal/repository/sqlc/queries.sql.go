// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const addClinicService = `-- name: AddClinicService :one

INSERT INTO clinic_services (
    clinic_id, service_name, service_category, description,
    duration_minutes, cost, cost_currency, is_covered_by_medical_aid,
    is_active, requires_appointment, walk_in_allowed
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, clinic_id, service_name, service_category, 
    is_active, created_at
`

type AddClinicServiceParams struct {
	ClinicID              pgtype.UUID    `json:"clinic_id"`
	ServiceName           string         `json:"service_name"`
	ServiceCategory       pgtype.Text    `json:"service_category"`
	Description           pgtype.Text    `json:"description"`
	DurationMinutes       pgtype.Int4    `json:"duration_minutes"`
	Cost                  pgtype.Numeric `json:"cost"`
	CostCurrency          pgtype.Text    `json:"cost_currency"`
	IsCoveredByMedicalAid pgtype.Bool    `json:"is_covered_by_medical_aid"`
	IsActive              pgtype.Bool    `json:"is_active"`
	RequiresAppointment   pgtype.Bool    `json:"requires_appointment"`
	WalkInAllowed         pgtype.Bool    `json:"walk_in_allowed"`
}

type AddClinicServiceRow struct {
	ID              pgtype.UUID      `json:"id"`
	ClinicID        pgtype.UUID      `json:"clinic_id"`
	ServiceName     string           `json:"service_name"`
	ServiceCategory pgtype.Text      `json:"service_category"`
	IsActive        pgtype.Bool      `json:"is_active"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Clinic Services Queries
// ============================================
func (q *Queries) AddClinicService(ctx context.Context, arg AddClinicServiceParams) (AddClinicServiceRow, error) {
	row := q.db.QueryRow(ctx, addClinicService,
		arg.ClinicID,
		arg.ServiceName,
		arg.ServiceCategory,
		arg.Description,
		arg.DurationMinutes,
		arg.Cost,
		arg.CostCurrency,
		arg.IsCoveredByMedicalAid,
		arg.IsActive,
		arg.RequiresAppointment,
		arg.WalkInAllowed,
	)
	var i AddClinicServiceRow
	err := row.Scan(
		&i.ID,
		&i.ClinicID,
		&i.ServiceName,
		&i.ServiceCategory,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const addPatientAllergy = `-- name: AddPatientAllergy :one

INSERT INTO patient_allergies (
    patient_id, allergy_name, severity, reaction_description, 
    first_identified_date, status, notes
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, patient_id, allergy_name, severity, status, created_at
`

type AddPatientAllergyParams struct {
	PatientID           pgtype.UUID `json:"patient_id"`
	AllergyName         string      `json:"allergy_name"`
	Severity            string      `json:"severity"`
	ReactionDescription pgtype.Text `json:"reaction_description"`
	FirstIdentifiedDate pgtype.Date `json:"first_identified_date"`
	Status              pgtype.Text `json:"status"`
	Notes               pgtype.Text `json:"notes"`
}

type AddPatientAllergyRow struct {
	ID          pgtype.UUID      `json:"id"`
	PatientID   pgtype.UUID      `json:"patient_id"`
	AllergyName string           `json:"allergy_name"`
	Severity    string           `json:"severity"`
	Status      pgtype.Text      `json:"status"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Patient Allergies Queries
// ============================================
func (q *Queries) AddPatientAllergy(ctx context.Context, arg AddPatientAllergyParams) (AddPatientAllergyRow, error) {
	row := q.db.QueryRow(ctx, addPatientAllergy,
		arg.PatientID,
		arg.AllergyName,
		arg.Severity,
		arg.ReactionDescription,
		arg.FirstIdentifiedDate,
		arg.Status,
		arg.Notes,
	)
	var i AddPatientAllergyRow
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.AllergyName,
		&i.Severity,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const addPatientCondition = `-- name: AddPatientCondition :one

INSERT INTO patient_conditions (
    patient_id, condition_name, icd10_code, type, diagnosed_date, 
    diagnosed_by, severity, status, notes
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, patient_id, condition_name, type, status, created_at
`

type AddPatientConditionParams struct {
	PatientID     pgtype.UUID `json:"patient_id"`
	ConditionName string      `json:"condition_name"`
	Icd10Code     pgtype.Text `json:"icd10_code"`
	Type          pgtype.Text `json:"type"`
	DiagnosedDate pgtype.Date `json:"diagnosed_date"`
	DiagnosedBy   pgtype.Text `json:"diagnosed_by"`
	Severity      pgtype.Text `json:"severity"`
	Status        pgtype.Text `json:"status"`
	Notes         pgtype.Text `json:"notes"`
}

type AddPatientConditionRow struct {
	ID            pgtype.UUID      `json:"id"`
	PatientID     pgtype.UUID      `json:"patient_id"`
	ConditionName string           `json:"condition_name"`
	Type          pgtype.Text      `json:"type"`
	Status        pgtype.Text      `json:"status"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Patient Conditions Queries
// ============================================
func (q *Queries) AddPatientCondition(ctx context.Context, arg AddPatientConditionParams) (AddPatientConditionRow, error) {
	row := q.db.QueryRow(ctx, addPatientCondition,
		arg.PatientID,
		arg.ConditionName,
		arg.Icd10Code,
		arg.Type,
		arg.DiagnosedDate,
		arg.DiagnosedBy,
		arg.Severity,
		arg.Status,
		arg.Notes,
	)
	var i AddPatientConditionRow
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.ConditionName,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const addPatientImmunization = `-- name: AddPatientImmunization :one

INSERT INTO patient_immunizations (
    patient_id, vaccine_name, vaccine_type, administration_date, 
    next_due_date, administered_by, clinic_name, lot_number, 
    manufacturer, dose_number, total_doses, documented_by
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, patient_id, vaccine_name, administration_date, next_due_date, created_at
`

type AddPatientImmunizationParams struct {
	PatientID          pgtype.UUID `json:"patient_id"`
	VaccineName        string      `json:"vaccine_name"`
	VaccineType        pgtype.Text `json:"vaccine_type"`
	AdministrationDate pgtype.Date `json:"administration_date"`
	NextDueDate        pgtype.Date `json:"next_due_date"`
	AdministeredBy     pgtype.Text `json:"administered_by"`
	ClinicName         pgtype.Text `json:"clinic_name"`
	LotNumber          pgtype.Text `json:"lot_number"`
	Manufacturer       pgtype.Text `json:"manufacturer"`
	DoseNumber         pgtype.Int4 `json:"dose_number"`
	TotalDoses         pgtype.Int4 `json:"total_doses"`
	DocumentedBy       pgtype.UUID `json:"documented_by"`
}

type AddPatientImmunizationRow struct {
	ID                 pgtype.UUID      `json:"id"`
	PatientID          pgtype.UUID      `json:"patient_id"`
	VaccineName        string           `json:"vaccine_name"`
	AdministrationDate pgtype.Date      `json:"administration_date"`
	NextDueDate        pgtype.Date      `json:"next_due_date"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Patient Immunizations Queries
// ============================================
func (q *Queries) AddPatientImmunization(ctx context.Context, arg AddPatientImmunizationParams) (AddPatientImmunizationRow, error) {
	row := q.db.QueryRow(ctx, addPatientImmunization,
		arg.PatientID,
		arg.VaccineName,
		arg.VaccineType,
		arg.AdministrationDate,
		arg.NextDueDate,
		arg.AdministeredBy,
		arg.ClinicName,
		arg.LotNumber,
		arg.Manufacturer,
		arg.DoseNumber,
		arg.TotalDoses,
		arg.DocumentedBy,
	)
	var i AddPatientImmunizationRow
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.VaccineName,
		&i.AdministrationDate,
		&i.NextDueDate,
		&i.CreatedAt,
	)
	return i, err
}

const addPatientMedication = `-- name: AddPatientMedication :one

INSERT INTO patient_medications (
    patient_id, medication_name, generic_name, dosage, frequency, 
    route, prescribing_doctor, pharmacy_name, prescription_date, 
    start_date, end_date, reason_for_medication, status, instructions
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, patient_id, medication_name, dosage, frequency, status, created_at
`

type AddPatientMedicationParams struct {
	PatientID           pgtype.UUID `json:"patient_id"`
	MedicationName      string      `json:"medication_name"`
	GenericName         pgtype.Text `json:"generic_name"`
	Dosage              pgtype.Text `json:"dosage"`
	Frequency           pgtype.Text `json:"frequency"`
	Route               pgtype.Text `json:"route"`
	PrescribingDoctor   pgtype.Text `json:"prescribing_doctor"`
	PharmacyName        pgtype.Text `json:"pharmacy_name"`
	PrescriptionDate    pgtype.Date `json:"prescription_date"`
	StartDate           pgtype.Date `json:"start_date"`
	EndDate             pgtype.Date `json:"end_date"`
	ReasonForMedication pgtype.Text `json:"reason_for_medication"`
	Status              pgtype.Text `json:"status"`
	Instructions        pgtype.Text `json:"instructions"`
}

type AddPatientMedicationRow struct {
	ID             pgtype.UUID      `json:"id"`
	PatientID      pgtype.UUID      `json:"patient_id"`
	MedicationName string           `json:"medication_name"`
	Dosage         pgtype.Text      `json:"dosage"`
	Frequency      pgtype.Text      `json:"frequency"`
	Status         pgtype.Text      `json:"status"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Patient Medications Queries
// ============================================
func (q *Queries) AddPatientMedication(ctx context.Context, arg AddPatientMedicationParams) (AddPatientMedicationRow, error) {
	row := q.db.QueryRow(ctx, addPatientMedication,
		arg.PatientID,
		arg.MedicationName,
		arg.GenericName,
		arg.Dosage,
		arg.Frequency,
		arg.Route,
		arg.PrescribingDoctor,
		arg.PharmacyName,
		arg.PrescriptionDate,
		arg.StartDate,
		arg.EndDate,
		arg.ReasonForMedication,
		arg.Status,
		arg.Instructions,
	)
	var i AddPatientMedicationRow
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.MedicationName,
		&i.Dosage,
		&i.Frequency,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const addProfessionalCredential = `-- name: AddProfessionalCredential :one

INSERT INTO professional_credentials (
    staff_id, credential_type, credential_number, issuing_authority,
    issue_date, expiry_date, status, document_url
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, staff_id, credential_type, issuing_authority, 
    status, created_at
`

type AddProfessionalCredentialParams struct {
	StaffID          pgtype.UUID `json:"staff_id"`
	CredentialType   string      `json:"credential_type"`
	CredentialNumber pgtype.Text `json:"credential_number"`
	IssuingAuthority string      `json:"issuing_authority"`
	IssueDate        pgtype.Date `json:"issue_date"`
	ExpiryDate       pgtype.Date `json:"expiry_date"`
	Status           pgtype.Text `json:"status"`
	DocumentUrl      pgtype.Text `json:"document_url"`
}

type AddProfessionalCredentialRow struct {
	ID               pgtype.UUID      `json:"id"`
	StaffID          pgtype.UUID      `json:"staff_id"`
	CredentialType   string           `json:"credential_type"`
	IssuingAuthority string           `json:"issuing_authority"`
	Status           pgtype.Text      `json:"status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Professional Credentials Queries
// ============================================
func (q *Queries) AddProfessionalCredential(ctx context.Context, arg AddProfessionalCredentialParams) (AddProfessionalCredentialRow, error) {
	row := q.db.QueryRow(ctx, addProfessionalCredential,
		arg.StaffID,
		arg.CredentialType,
		arg.CredentialNumber,
		arg.IssuingAuthority,
		arg.IssueDate,
		arg.ExpiryDate,
		arg.Status,
		arg.DocumentUrl,
	)
	var i AddProfessionalCredentialRow
	err := row.Scan(
		&i.ID,
		&i.StaffID,
		&i.CredentialType,
		&i.IssuingAuthority,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const countUsersByRole = `-- name: CountUsersByRole :one
SELECT COUNT(*) FROM users 
WHERE role = $1 AND status != 'inactive'
`

func (q *Queries) CountUsersByRole(ctx context.Context, role string) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersByRole, role)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createClinic = `-- name: CreateClinic :one

INSERT INTO clinics (
    clinic_name, clinic_type, registration_number, primary_phone, 
    email, physical_address, city, province, postal_code, country,
    latitude, longitude, description, ownership_type, 
    accepts_medical_aid, verification_status
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, clinic_name, clinic_type, city, province, 
    verification_status, created_at, updated_at
`

type CreateClinicParams struct {
	ClinicName         string         `json:"clinic_name"`
	ClinicType         string         `json:"clinic_type"`
	RegistrationNumber pgtype.Text    `json:"registration_number"`
	PrimaryPhone       pgtype.Text    `json:"primary_phone"`
	Email              pgtype.Text    `json:"email"`
	PhysicalAddress    string         `json:"physical_address"`
	City               pgtype.Text    `json:"city"`
	Province           pgtype.Text    `json:"province"`
	PostalCode         pgtype.Text    `json:"postal_code"`
	Country            pgtype.Text    `json:"country"`
	Latitude           pgtype.Numeric `json:"latitude"`
	Longitude          pgtype.Numeric `json:"longitude"`
	Description        pgtype.Text    `json:"description"`
	OwnershipType      pgtype.Text    `json:"ownership_type"`
	AcceptsMedicalAid  pgtype.Bool    `json:"accepts_medical_aid"`
	VerificationStatus pgtype.Text    `json:"verification_status"`
}

type CreateClinicRow struct {
	ID                 pgtype.UUID      `json:"id"`
	ClinicName         string           `json:"clinic_name"`
	ClinicType         string           `json:"clinic_type"`
	City               pgtype.Text      `json:"city"`
	Province           pgtype.Text      `json:"province"`
	VerificationStatus pgtype.Text      `json:"verification_status"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
	UpdatedAt          pgtype.Timestamp `json:"updated_at"`
}

// ============================================
// Clinic Queries
// ============================================
func (q *Queries) CreateClinic(ctx context.Context, arg CreateClinicParams) (CreateClinicRow, error) {
	row := q.db.QueryRow(ctx, createClinic,
		arg.ClinicName,
		arg.ClinicType,
		arg.RegistrationNumber,
		arg.PrimaryPhone,
		arg.Email,
		arg.PhysicalAddress,
		arg.City,
		arg.Province,
		arg.PostalCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.Description,
		arg.OwnershipType,
		arg.AcceptsMedicalAid,
		arg.VerificationStatus,
	)
	var i CreateClinicRow
	err := row.Scan(
		&i.ID,
		&i.ClinicName,
		&i.ClinicType,
		&i.City,
		&i.Province,
		&i.VerificationStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createClinicStaff = `-- name: CreateClinicStaff :one

INSERT INTO clinic_staff (
    clinic_id, user_id, title, first_name, last_name, 
    professional_title, specialization, work_email, work_phone,
    hpcs_number, staff_role, employment_status, 
    is_accepting_new_patients
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, clinic_id, user_id, first_name, last_name, 
    staff_role, employment_status, created_at
`

type CreateClinicStaffParams struct {
	ClinicID               pgtype.UUID `json:"clinic_id"`
	UserID                 pgtype.UUID `json:"user_id"`
	Title                  pgtype.Text `json:"title"`
	FirstName              string      `json:"first_name"`
	LastName               string      `json:"last_name"`
	ProfessionalTitle      pgtype.Text `json:"professional_title"`
	Specialization         pgtype.Text `json:"specialization"`
	WorkEmail              pgtype.Text `json:"work_email"`
	WorkPhone              pgtype.Text `json:"work_phone"`
	HpcsNumber             pgtype.Text `json:"hpcs_number"`
	StaffRole              string      `json:"staff_role"`
	EmploymentStatus       pgtype.Text `json:"employment_status"`
	IsAcceptingNewPatients pgtype.Bool `json:"is_accepting_new_patients"`
}

type CreateClinicStaffRow struct {
	ID               pgtype.UUID      `json:"id"`
	ClinicID         pgtype.UUID      `json:"clinic_id"`
	UserID           pgtype.UUID      `json:"user_id"`
	FirstName        string           `json:"first_name"`
	LastName         string           `json:"last_name"`
	StaffRole        string           `json:"staff_role"`
	EmploymentStatus pgtype.Text      `json:"employment_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Clinic Staff Queries
// ============================================
func (q *Queries) CreateClinicStaff(ctx context.Context, arg CreateClinicStaffParams) (CreateClinicStaffRow, error) {
	row := q.db.QueryRow(ctx, createClinicStaff,
		arg.ClinicID,
		arg.UserID,
		arg.Title,
		arg.FirstName,
		arg.LastName,
		arg.ProfessionalTitle,
		arg.Specialization,
		arg.WorkEmail,
		arg.WorkPhone,
		arg.HpcsNumber,
		arg.StaffRole,
		arg.EmploymentStatus,
		arg.IsAcceptingNewPatients,
	)
	var i CreateClinicStaffRow
	err := row.Scan(
		&i.ID,
		&i.ClinicID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.StaffRole,
		&i.EmploymentStatus,
		&i.CreatedAt,
	)
	return i, err
}

const createNotificationPreferences = `-- name: CreateNotificationPreferences :one

INSERT INTO notification_preferences (
    user_id, sms_enabled, email_enabled, push_enabled,
    appointment_reminders, health_tips, notification_language
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, created_at
`

type CreateNotificationPreferencesParams struct {
	UserID               pgtype.UUID `json:"user_id"`
	SmsEnabled           pgtype.Bool `json:"sms_enabled"`
	EmailEnabled         pgtype.Bool `json:"email_enabled"`
	PushEnabled          pgtype.Bool `json:"push_enabled"`
	AppointmentReminders pgtype.Bool `json:"appointment_reminders"`
	HealthTips           pgtype.Bool `json:"health_tips"`
	NotificationLanguage pgtype.Text `json:"notification_language"`
}

type CreateNotificationPreferencesRow struct {
	ID        pgtype.UUID      `json:"id"`
	UserID    pgtype.UUID      `json:"user_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Notification Preferences Queries
// ============================================
func (q *Queries) CreateNotificationPreferences(ctx context.Context, arg CreateNotificationPreferencesParams) (CreateNotificationPreferencesRow, error) {
	row := q.db.QueryRow(ctx, createNotificationPreferences,
		arg.UserID,
		arg.SmsEnabled,
		arg.EmailEnabled,
		arg.PushEnabled,
		arg.AppointmentReminders,
		arg.HealthTips,
		arg.NotificationLanguage,
	)
	var i CreateNotificationPreferencesRow
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const createPatientMedicalInfo = `-- name: CreatePatientMedicalInfo :one

INSERT INTO patient_medical_info (
    patient_id, blood_type, height_cm, weight_kg, bmi, 
    overall_health_status, health_summary, primary_care_physician, 
    primary_clinic_id, organ_donor, dnr_status
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, patient_id, blood_type, overall_health_status, created_at, updated_at
`

type CreatePatientMedicalInfoParams struct {
	PatientID            pgtype.UUID    `json:"patient_id"`
	BloodType            pgtype.Text    `json:"blood_type"`
	HeightCm             pgtype.Numeric `json:"height_cm"`
	WeightKg             pgtype.Numeric `json:"weight_kg"`
	Bmi                  pgtype.Numeric `json:"bmi"`
	OverallHealthStatus  pgtype.Text    `json:"overall_health_status"`
	HealthSummary        pgtype.Text    `json:"health_summary"`
	PrimaryCarePhysician pgtype.Text    `json:"primary_care_physician"`
	PrimaryClinicID      pgtype.UUID    `json:"primary_clinic_id"`
	OrganDonor           pgtype.Bool    `json:"organ_donor"`
	DnrStatus            pgtype.Bool    `json:"dnr_status"`
}

type CreatePatientMedicalInfoRow struct {
	ID                  pgtype.UUID      `json:"id"`
	PatientID           pgtype.UUID      `json:"patient_id"`
	BloodType           pgtype.Text      `json:"blood_type"`
	OverallHealthStatus pgtype.Text      `json:"overall_health_status"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
}

// ============================================
// Patient Medical Info Queries
// ============================================
func (q *Queries) CreatePatientMedicalInfo(ctx context.Context, arg CreatePatientMedicalInfoParams) (CreatePatientMedicalInfoRow, error) {
	row := q.db.QueryRow(ctx, createPatientMedicalInfo,
		arg.PatientID,
		arg.BloodType,
		arg.HeightCm,
		arg.WeightKg,
		arg.Bmi,
		arg.OverallHealthStatus,
		arg.HealthSummary,
		arg.PrimaryCarePhysician,
		arg.PrimaryClinicID,
		arg.OrganDonor,
		arg.DnrStatus,
	)
	var i CreatePatientMedicalInfoRow
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.BloodType,
		&i.OverallHealthStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPatientProfile = `-- name: CreatePatientProfile :one

INSERT INTO patient_profiles (
    user_id, first_name, last_name, preferred_name, date_of_birth, 
    gender, preferred_gender_pronouns, primary_address, city, province, 
    postal_code, country, language_preferences, home_language, 
    requires_interpreter, preferred_communication_method, 
    medical_aid_number, medical_aid_provider, has_medical_aid, 
    national_id_number, timezone
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)
RETURNING id, user_id, first_name, last_name, preferred_name, 
    date_of_birth, gender, city, province, country, 
    preferred_communication_method, created_at, updated_at
`

type CreatePatientProfileParams struct {
	UserID                       pgtype.UUID `json:"user_id"`
	FirstName                    string      `json:"first_name"`
	LastName                     string      `json:"last_name"`
	PreferredName                pgtype.Text `json:"preferred_name"`
	DateOfBirth                  pgtype.Date `json:"date_of_birth"`
	Gender                       pgtype.Text `json:"gender"`
	PreferredGenderPronouns      pgtype.Text `json:"preferred_gender_pronouns"`
	PrimaryAddress               pgtype.Text `json:"primary_address"`
	City                         pgtype.Text `json:"city"`
	Province                     pgtype.Text `json:"province"`
	PostalCode                   pgtype.Text `json:"postal_code"`
	Country                      pgtype.Text `json:"country"`
	LanguagePreferences          []string    `json:"language_preferences"`
	HomeLanguage                 pgtype.Text `json:"home_language"`
	RequiresInterpreter          pgtype.Bool `json:"requires_interpreter"`
	PreferredCommunicationMethod pgtype.Text `json:"preferred_communication_method"`
	MedicalAidNumber             pgtype.Text `json:"medical_aid_number"`
	MedicalAidProvider           pgtype.Text `json:"medical_aid_provider"`
	HasMedicalAid                pgtype.Bool `json:"has_medical_aid"`
	NationalIDNumber             pgtype.Text `json:"national_id_number"`
	Timezone                     pgtype.Text `json:"timezone"`
}

type CreatePatientProfileRow struct {
	ID                           pgtype.UUID      `json:"id"`
	UserID                       pgtype.UUID      `json:"user_id"`
	FirstName                    string           `json:"first_name"`
	LastName                     string           `json:"last_name"`
	PreferredName                pgtype.Text      `json:"preferred_name"`
	DateOfBirth                  pgtype.Date      `json:"date_of_birth"`
	Gender                       pgtype.Text      `json:"gender"`
	City                         pgtype.Text      `json:"city"`
	Province                     pgtype.Text      `json:"province"`
	Country                      pgtype.Text      `json:"country"`
	PreferredCommunicationMethod pgtype.Text      `json:"preferred_communication_method"`
	CreatedAt                    pgtype.Timestamp `json:"created_at"`
	UpdatedAt                    pgtype.Timestamp `json:"updated_at"`
}

// ============================================
// Patient Profile Queries
// ============================================
func (q *Queries) CreatePatientProfile(ctx context.Context, arg CreatePatientProfileParams) (CreatePatientProfileRow, error) {
	row := q.db.QueryRow(ctx, createPatientProfile,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.PreferredName,
		arg.DateOfBirth,
		arg.Gender,
		arg.PreferredGenderPronouns,
		arg.PrimaryAddress,
		arg.City,
		arg.Province,
		arg.PostalCode,
		arg.Country,
		arg.LanguagePreferences,
		arg.HomeLanguage,
		arg.RequiresInterpreter,
		arg.PreferredCommunicationMethod,
		arg.MedicalAidNumber,
		arg.MedicalAidProvider,
		arg.HasMedicalAid,
		arg.NationalIDNumber,
		arg.Timezone,
	)
	var i CreatePatientProfileRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.PreferredName,
		&i.DateOfBirth,
		&i.Gender,
		&i.City,
		&i.Province,
		&i.Country,
		&i.PreferredCommunicationMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPrivacyConsent = `-- name: CreatePrivacyConsent :one

INSERT INTO privacy_consents (
    user_id, health_data_consent, health_data_consent_date,
    health_data_consent_version, emergency_access_consent,
    sms_communication_consent, email_communication_consent,
    ip_address, user_agent
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, user_id, health_data_consent, created_at
`

type CreatePrivacyConsentParams struct {
	UserID                    pgtype.UUID      `json:"user_id"`
	HealthDataConsent         pgtype.Bool      `json:"health_data_consent"`
	HealthDataConsentDate     pgtype.Timestamp `json:"health_data_consent_date"`
	HealthDataConsentVersion  pgtype.Text      `json:"health_data_consent_version"`
	EmergencyAccessConsent    pgtype.Bool      `json:"emergency_access_consent"`
	SmsCommunicationConsent   pgtype.Bool      `json:"sms_communication_consent"`
	EmailCommunicationConsent pgtype.Bool      `json:"email_communication_consent"`
	IpAddress                 *netip.Addr      `json:"ip_address"`
	UserAgent                 pgtype.Text      `json:"user_agent"`
}

type CreatePrivacyConsentRow struct {
	ID                pgtype.UUID      `json:"id"`
	UserID            pgtype.UUID      `json:"user_id"`
	HealthDataConsent pgtype.Bool      `json:"health_data_consent"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Privacy Consent Queries (POPIA Compliance)
// ============================================
func (q *Queries) CreatePrivacyConsent(ctx context.Context, arg CreatePrivacyConsentParams) (CreatePrivacyConsentRow, error) {
	row := q.db.QueryRow(ctx, createPrivacyConsent,
		arg.UserID,
		arg.HealthDataConsent,
		arg.HealthDataConsentDate,
		arg.HealthDataConsentVersion,
		arg.EmergencyAccessConsent,
		arg.SmsCommunicationConsent,
		arg.EmailCommunicationConsent,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i CreatePrivacyConsentRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.HealthDataConsent,
		&i.CreatedAt,
	)
	return i, err
}

const createSMSConversation = `-- name: CreateSMSConversation :one

INSERT INTO sms_conversations (
    user_id, phone_number, current_menu, conversation_state
)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, phone_number, created_at
`

type CreateSMSConversationParams struct {
	UserID            pgtype.UUID `json:"user_id"`
	PhoneNumber       string      `json:"phone_number"`
	CurrentMenu       pgtype.Text `json:"current_menu"`
	ConversationState []byte      `json:"conversation_state"`
}

type CreateSMSConversationRow struct {
	ID          pgtype.UUID      `json:"id"`
	UserID      pgtype.UUID      `json:"user_id"`
	PhoneNumber string           `json:"phone_number"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

// ============================================
// SMS Conversation Queries
// ============================================
func (q *Queries) CreateSMSConversation(ctx context.Context, arg CreateSMSConversationParams) (CreateSMSConversationRow, error) {
	row := q.db.QueryRow(ctx, createSMSConversation,
		arg.UserID,
		arg.PhoneNumber,
		arg.CurrentMenu,
		arg.ConversationState,
	)
	var i CreateSMSConversationRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PhoneNumber,
		&i.CreatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one

INSERT INTO user_sessions (
    user_id, session_token, device_type, device_id, 
    ip_address, user_agent, expires_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, session_token, expires_at, created_at
`

type CreateSessionParams struct {
	UserID       pgtype.UUID      `json:"user_id"`
	SessionToken string           `json:"session_token"`
	DeviceType   pgtype.Text      `json:"device_type"`
	DeviceID     pgtype.Text      `json:"device_id"`
	IpAddress    *netip.Addr      `json:"ip_address"`
	UserAgent    pgtype.Text      `json:"user_agent"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
}

type CreateSessionRow struct {
	ID           pgtype.UUID      `json:"id"`
	UserID       pgtype.UUID      `json:"user_id"`
	SessionToken string           `json:"session_token"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
}

// ============================================
// Session Management Queries
// ============================================
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (CreateSessionRow, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.SessionToken,
		arg.DeviceType,
		arg.DeviceID,
		arg.IpAddress,
		arg.UserAgent,
		arg.ExpiresAt,
	)
	var i CreateSessionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
    email, phone, password_hash, role, status, 
    is_sms_only, sms_consent_given, popia_consent_given, consent_date
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, email, phone, role, status, is_verified, last_login, 
    login_count, is_sms_only, profile_completion_percentage, created_at, updated_at
`

type CreateUserParams struct {
	Email             string           `json:"email"`
	Phone             pgtype.Text      `json:"phone"`
	PasswordHash      pgtype.Text      `json:"password_hash"`
	Role              string           `json:"role"`
	Status            pgtype.Text      `json:"status"`
	IsSmsOnly         pgtype.Bool      `json:"is_sms_only"`
	SmsConsentGiven   pgtype.Bool      `json:"sms_consent_given"`
	PopiaConsentGiven pgtype.Bool      `json:"popia_consent_given"`
	ConsentDate       pgtype.Timestamp `json:"consent_date"`
}

type CreateUserRow struct {
	ID                          pgtype.UUID      `json:"id"`
	Email                       string           `json:"email"`
	Phone                       pgtype.Text      `json:"phone"`
	Role                        string           `json:"role"`
	Status                      pgtype.Text      `json:"status"`
	IsVerified                  pgtype.Bool      `json:"is_verified"`
	LastLogin                   pgtype.Timestamp `json:"last_login"`
	LoginCount                  pgtype.Int4      `json:"login_count"`
	IsSmsOnly                   pgtype.Bool      `json:"is_sms_only"`
	ProfileCompletionPercentage pgtype.Int4      `json:"profile_completion_percentage"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
	UpdatedAt                   pgtype.Timestamp `json:"updated_at"`
}

// ============================================
// User Management Queries
// ============================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Phone,
		arg.PasswordHash,
		arg.Role,
		arg.Status,
		arg.IsSmsOnly,
		arg.SmsConsentGiven,
		arg.PopiaConsentGiven,
		arg.ConsentDate,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.Role,
		&i.Status,
		&i.IsVerified,
		&i.LastLogin,
		&i.LoginCount,
		&i.IsSmsOnly,
		&i.ProfileCompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateClinicService = `-- name: DeactivateClinicService :exec
UPDATE clinic_services SET is_active = FALSE WHERE id = $1
`

func (q *Queries) DeactivateClinicService(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateClinicService, id)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM user_sessions WHERE expires_at <= NOW()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deletePatientAllergy = `-- name: DeletePatientAllergy :exec
DELETE FROM patient_allergies WHERE id = $1
`

func (q *Queries) DeletePatientAllergy(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePatientAllergy, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM user_sessions WHERE session_token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, sessionToken string) error {
	_, err := q.db.Exec(ctx, deleteSession, sessionToken)
	return err
}

const deleteUserSessions = `-- name: DeleteUserSessions :exec
DELETE FROM user_sessions WHERE user_id = $1
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserSessions, userID)
	return err
}

const getClinicByID = `-- name: GetClinicByID :one
SELECT id, clinic_name, clinic_type, registration_number, accreditation_number, primary_phone, secondary_phone, emergency_phone, email, website, physical_address, city, province, postal_code, country, latitude, longitude, google_place_id, description, year_established, ownership_type, bed_count, operating_hours, services, specialties, languages_spoken, facilities, accepts_medical_aid, medical_aid_providers, payment_methods, fee_structure, accreditation_body, accreditation_expiry, certifications, is_verified, verification_status, verification_notes, verified_by, verification_date, patient_capacity, average_wait_time_minutes, rating, review_count, contact_person_name, contact_person_role, contact_person_phone, contact_person_email, created_at, updated_at FROM clinics WHERE id = $1
`

func (q *Queries) GetClinicByID(ctx context.Context, id pgtype.UUID) (Clinic, error) {
	row := q.db.QueryRow(ctx, getClinicByID, id)
	var i Clinic
	err := row.Scan(
		&i.ID,
		&i.ClinicName,
		&i.ClinicType,
		&i.RegistrationNumber,
		&i.AccreditationNumber,
		&i.PrimaryPhone,
		&i.SecondaryPhone,
		&i.EmergencyPhone,
		&i.Email,
		&i.Website,
		&i.PhysicalAddress,
		&i.City,
		&i.Province,
		&i.PostalCode,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.GooglePlaceID,
		&i.Description,
		&i.YearEstablished,
		&i.OwnershipType,
		&i.BedCount,
		&i.OperatingHours,
		&i.Services,
		&i.Specialties,
		&i.LanguagesSpoken,
		&i.Facilities,
		&i.AcceptsMedicalAid,
		&i.MedicalAidProviders,
		&i.PaymentMethods,
		&i.FeeStructure,
		&i.AccreditationBody,
		&i.AccreditationExpiry,
		&i.Certifications,
		&i.IsVerified,
		&i.VerificationStatus,
		&i.VerificationNotes,
		&i.VerifiedBy,
		&i.VerificationDate,
		&i.PatientCapacity,
		&i.AverageWaitTimeMinutes,
		&i.Rating,
		&i.ReviewCount,
		&i.ContactPersonName,
		&i.ContactPersonRole,
		&i.ContactPersonPhone,
		&i.ContactPersonEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClinicServices = `-- name: GetClinicServices :many
SELECT id, clinic_id, service_name, service_category, description,
    duration_minutes, cost, cost_currency, is_covered_by_medical_aid,
    is_active, requires_appointment, walk_in_allowed, 
    average_rating, review_count
FROM clinic_services
WHERE clinic_id = $1 AND is_active = TRUE
ORDER BY popularity_score DESC, service_name ASC
`

type GetClinicServicesRow struct {
	ID                    pgtype.UUID    `json:"id"`
	ClinicID              pgtype.UUID    `json:"clinic_id"`
	ServiceName           string         `json:"service_name"`
	ServiceCategory       pgtype.Text    `json:"service_category"`
	Description           pgtype.Text    `json:"description"`
	DurationMinutes       pgtype.Int4    `json:"duration_minutes"`
	Cost                  pgtype.Numeric `json:"cost"`
	CostCurrency          pgtype.Text    `json:"cost_currency"`
	IsCoveredByMedicalAid pgtype.Bool    `json:"is_covered_by_medical_aid"`
	IsActive              pgtype.Bool    `json:"is_active"`
	RequiresAppointment   pgtype.Bool    `json:"requires_appointment"`
	WalkInAllowed         pgtype.Bool    `json:"walk_in_allowed"`
	AverageRating         pgtype.Numeric `json:"average_rating"`
	ReviewCount           pgtype.Int4    `json:"review_count"`
}

func (q *Queries) GetClinicServices(ctx context.Context, clinicID pgtype.UUID) ([]GetClinicServicesRow, error) {
	rows, err := q.db.Query(ctx, getClinicServices, clinicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClinicServicesRow
	for rows.Next() {
		var i GetClinicServicesRow
		if err := rows.Scan(
			&i.ID,
			&i.ClinicID,
			&i.ServiceName,
			&i.ServiceCategory,
			&i.Description,
			&i.DurationMinutes,
			&i.Cost,
			&i.CostCurrency,
			&i.IsCoveredByMedicalAid,
			&i.IsActive,
			&i.RequiresAppointment,
			&i.WalkInAllowed,
			&i.AverageRating,
			&i.ReviewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClinicStaffByID = `-- name: GetClinicStaffByID :one
SELECT id, clinic_id, user_id, title, first_name, last_name, professional_title, specialization, work_email, work_phone, personal_phone, hpcs_number, other_license_numbers, qualifications, years_experience, bio, staff_role, department, is_primary_contact, working_hours, available_days, is_accepting_new_patients, employment_status, start_date, end_date, profile_picture_url, languages_spoken, created_at, updated_at FROM clinic_staff WHERE id = $1
`

func (q *Queries) GetClinicStaffByID(ctx context.Context, id pgtype.UUID) (ClinicStaff, error) {
	row := q.db.QueryRow(ctx, getClinicStaffByID, id)
	var i ClinicStaff
	err := row.Scan(
		&i.ID,
		&i.ClinicID,
		&i.UserID,
		&i.Title,
		&i.FirstName,
		&i.LastName,
		&i.ProfessionalTitle,
		&i.Specialization,
		&i.WorkEmail,
		&i.WorkPhone,
		&i.PersonalPhone,
		&i.HpcsNumber,
		&i.OtherLicenseNumbers,
		&i.Qualifications,
		&i.YearsExperience,
		&i.Bio,
		&i.StaffRole,
		&i.Department,
		&i.IsPrimaryContact,
		&i.WorkingHours,
		&i.AvailableDays,
		&i.IsAcceptingNewPatients,
		&i.EmploymentStatus,
		&i.StartDate,
		&i.EndDate,
		&i.ProfilePictureUrl,
		&i.LanguagesSpoken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClinicStaffByUserID = `-- name: GetClinicStaffByUserID :one
SELECT id, clinic_id, user_id, title, first_name, last_name, professional_title, specialization, work_email, work_phone, personal_phone, hpcs_number, other_license_numbers, qualifications, years_experience, bio, staff_role, department, is_primary_contact, working_hours, available_days, is_accepting_new_patients, employment_status, start_date, end_date, profile_picture_url, languages_spoken, created_at, updated_at FROM clinic_staff WHERE user_id = $1
`

func (q *Queries) GetClinicStaffByUserID(ctx context.Context, userID pgtype.UUID) (ClinicStaff, error) {
	row := q.db.QueryRow(ctx, getClinicStaffByUserID, userID)
	var i ClinicStaff
	err := row.Scan(
		&i.ID,
		&i.ClinicID,
		&i.UserID,
		&i.Title,
		&i.FirstName,
		&i.LastName,
		&i.ProfessionalTitle,
		&i.Specialization,
		&i.WorkEmail,
		&i.WorkPhone,
		&i.PersonalPhone,
		&i.HpcsNumber,
		&i.OtherLicenseNumbers,
		&i.Qualifications,
		&i.YearsExperience,
		&i.Bio,
		&i.StaffRole,
		&i.Department,
		&i.IsPrimaryContact,
		&i.WorkingHours,
		&i.AvailableDays,
		&i.IsAcceptingNewPatients,
		&i.EmploymentStatus,
		&i.StartDate,
		&i.EndDate,
		&i.ProfilePictureUrl,
		&i.LanguagesSpoken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT id, conversation_id, direction, message_body, 
    twilio_status, sent_at, delivered_at, created_at
FROM sms_messages
WHERE conversation_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetConversationMessagesParams struct {
	ConversationID pgtype.UUID `json:"conversation_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetConversationMessagesRow struct {
	ID             pgtype.UUID      `json:"id"`
	ConversationID pgtype.UUID      `json:"conversation_id"`
	Direction      string           `json:"direction"`
	MessageBody    string           `json:"message_body"`
	TwilioStatus   pgtype.Text      `json:"twilio_status"`
	SentAt         pgtype.Timestamp `json:"sent_at"`
	DeliveredAt    pgtype.Timestamp `json:"delivered_at"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetConversationMessages(ctx context.Context, arg GetConversationMessagesParams) ([]GetConversationMessagesRow, error) {
	rows, err := q.db.Query(ctx, getConversationMessages, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationMessagesRow
	for rows.Next() {
		var i GetConversationMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.Direction,
			&i.MessageBody,
			&i.TwilioStatus,
			&i.SentAt,
			&i.DeliveredAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataAccessLogs = `-- name: GetDataAccessLogs :many
SELECT id, accessed_by_user_id, accessed_by_role, accessed_resource_type,
    accessed_resource_id, access_type, access_reason, 
    is_emergency_access, accessed_at
FROM data_access_logs
WHERE accessed_user_id = $1
ORDER BY accessed_at DESC
LIMIT $2 OFFSET $3
`

type GetDataAccessLogsParams struct {
	AccessedUserID pgtype.UUID `json:"accessed_user_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetDataAccessLogsRow struct {
	ID                   pgtype.UUID      `json:"id"`
	AccessedByUserID     pgtype.UUID      `json:"accessed_by_user_id"`
	AccessedByRole       pgtype.Text      `json:"accessed_by_role"`
	AccessedResourceType pgtype.Text      `json:"accessed_resource_type"`
	AccessedResourceID   pgtype.UUID      `json:"accessed_resource_id"`
	AccessType           pgtype.Text      `json:"access_type"`
	AccessReason         pgtype.Text      `json:"access_reason"`
	IsEmergencyAccess    pgtype.Bool      `json:"is_emergency_access"`
	AccessedAt           pgtype.Timestamp `json:"accessed_at"`
}

func (q *Queries) GetDataAccessLogs(ctx context.Context, arg GetDataAccessLogsParams) ([]GetDataAccessLogsRow, error) {
	rows, err := q.db.Query(ctx, getDataAccessLogs, arg.AccessedUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDataAccessLogsRow
	for rows.Next() {
		var i GetDataAccessLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccessedByUserID,
			&i.AccessedByRole,
			&i.AccessedResourceType,
			&i.AccessedResourceID,
			&i.AccessType,
			&i.AccessReason,
			&i.IsEmergencyAccess,
			&i.AccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationPreferences = `-- name: GetNotificationPreferences :one
SELECT id, user_id, sms_enabled, email_enabled, push_enabled, whatsapp_enabled, appointment_reminders, appointment_reminder_hours_before, health_tips, health_tips_frequency, medication_reminders, prescription_updates, clinic_updates, newsletter, emergency_alerts, system_maintenance, notification_language, quiet_hours_start, quiet_hours_end, created_at, updated_at FROM notification_preferences WHERE user_id = $1
`

func (q *Queries) GetNotificationPreferences(ctx context.Context, userID pgtype.UUID) (NotificationPreference, error) {
	row := q.db.QueryRow(ctx, getNotificationPreferences, userID)
	var i NotificationPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SmsEnabled,
		&i.EmailEnabled,
		&i.PushEnabled,
		&i.WhatsappEnabled,
		&i.AppointmentReminders,
		&i.AppointmentReminderHoursBefore,
		&i.HealthTips,
		&i.HealthTipsFrequency,
		&i.MedicationReminders,
		&i.PrescriptionUpdates,
		&i.ClinicUpdates,
		&i.Newsletter,
		&i.EmergencyAlerts,
		&i.SystemMaintenance,
		&i.NotificationLanguage,
		&i.QuietHoursStart,
		&i.QuietHoursEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPatientAllergies = `-- name: GetPatientAllergies :many
SELECT id, patient_id, allergy_name, severity, reaction_description,
    first_identified_date, last_occurrence_date, status, notes, 
    created_at, updated_at
FROM patient_allergies
WHERE patient_id = $1
ORDER BY severity DESC, created_at DESC
`

func (q *Queries) GetPatientAllergies(ctx context.Context, patientID pgtype.UUID) ([]PatientAllergy, error) {
	rows, err := q.db.Query(ctx, getPatientAllergies, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PatientAllergy
	for rows.Next() {
		var i PatientAllergy
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.AllergyName,
			&i.Severity,
			&i.ReactionDescription,
			&i.FirstIdentifiedDate,
			&i.LastOccurrenceDate,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatientConditions = `-- name: GetPatientConditions :many
SELECT id, patient_id, condition_name, icd10_code, type, 
    diagnosed_date, diagnosed_by, severity, status, notes,
    last_flare_up, next_checkup_date, created_at, updated_at
FROM patient_conditions
WHERE patient_id = $1
    AND ($2::VARCHAR IS NULL OR status = $2)
ORDER BY diagnosed_date DESC
`

type GetPatientConditionsParams struct {
	PatientID pgtype.UUID `json:"patient_id"`
	Column2   string      `json:"column_2"`
}

func (q *Queries) GetPatientConditions(ctx context.Context, arg GetPatientConditionsParams) ([]PatientCondition, error) {
	rows, err := q.db.Query(ctx, getPatientConditions, arg.PatientID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PatientCondition
	for rows.Next() {
		var i PatientCondition
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.ConditionName,
			&i.Icd10Code,
			&i.Type,
			&i.DiagnosedDate,
			&i.DiagnosedBy,
			&i.Severity,
			&i.Status,
			&i.Notes,
			&i.LastFlareUp,
			&i.NextCheckupDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatientImmunizations = `-- name: GetPatientImmunizations :many
SELECT id, patient_id, vaccine_name, vaccine_type, administration_date,
    next_due_date, administered_by, clinic_name, dose_number, 
    total_doses, notes, created_at
FROM patient_immunizations
WHERE patient_id = $1
ORDER BY administration_date DESC
`

type GetPatientImmunizationsRow struct {
	ID                 pgtype.UUID      `json:"id"`
	PatientID          pgtype.UUID      `json:"patient_id"`
	VaccineName        string           `json:"vaccine_name"`
	VaccineType        pgtype.Text      `json:"vaccine_type"`
	AdministrationDate pgtype.Date      `json:"administration_date"`
	NextDueDate        pgtype.Date      `json:"next_due_date"`
	AdministeredBy     pgtype.Text      `json:"administered_by"`
	ClinicName         pgtype.Text      `json:"clinic_name"`
	DoseNumber         pgtype.Int4      `json:"dose_number"`
	TotalDoses         pgtype.Int4      `json:"total_doses"`
	Notes              pgtype.Text      `json:"notes"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetPatientImmunizations(ctx context.Context, patientID pgtype.UUID) ([]GetPatientImmunizationsRow, error) {
	rows, err := q.db.Query(ctx, getPatientImmunizations, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPatientImmunizationsRow
	for rows.Next() {
		var i GetPatientImmunizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.VaccineName,
			&i.VaccineType,
			&i.AdministrationDate,
			&i.NextDueDate,
			&i.AdministeredBy,
			&i.ClinicName,
			&i.DoseNumber,
			&i.TotalDoses,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatientMedicalInfo = `-- name: GetPatientMedicalInfo :one
SELECT id, patient_id, blood_type, blood_type_last_tested, height_cm, weight_kg, bmi, last_measured_date, overall_health_status, health_summary, primary_care_physician, primary_clinic_id, organ_donor, advance_directive_exists, advance_directive_url, dnr_status, created_at, updated_at FROM patient_medical_info WHERE patient_id = $1
`

func (q *Queries) GetPatientMedicalInfo(ctx context.Context, patientID pgtype.UUID) (PatientMedicalInfo, error) {
	row := q.db.QueryRow(ctx, getPatientMedicalInfo, patientID)
	var i PatientMedicalInfo
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.BloodType,
		&i.BloodTypeLastTested,
		&i.HeightCm,
		&i.WeightKg,
		&i.Bmi,
		&i.LastMeasuredDate,
		&i.OverallHealthStatus,
		&i.HealthSummary,
		&i.PrimaryCarePhysician,
		&i.PrimaryClinicID,
		&i.OrganDonor,
		&i.AdvanceDirectiveExists,
		&i.AdvanceDirectiveUrl,
		&i.DnrStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPatientMedications = `-- name: GetPatientMedications :many
SELECT id, patient_id, medication_name, generic_name, dosage, 
    frequency, route, prescribing_doctor, start_date, end_date,
    reason_for_medication, status, instructions, created_at, updated_at
FROM patient_medications
WHERE patient_id = $1 
    AND ($2::VARCHAR IS NULL OR status = $2)
ORDER BY start_date DESC
`

type GetPatientMedicationsParams struct {
	PatientID pgtype.UUID `json:"patient_id"`
	Column2   string      `json:"column_2"`
}

type GetPatientMedicationsRow struct {
	ID                  pgtype.UUID      `json:"id"`
	PatientID           pgtype.UUID      `json:"patient_id"`
	MedicationName      string           `json:"medication_name"`
	GenericName         pgtype.Text      `json:"generic_name"`
	Dosage              pgtype.Text      `json:"dosage"`
	Frequency           pgtype.Text      `json:"frequency"`
	Route               pgtype.Text      `json:"route"`
	PrescribingDoctor   pgtype.Text      `json:"prescribing_doctor"`
	StartDate           pgtype.Date      `json:"start_date"`
	EndDate             pgtype.Date      `json:"end_date"`
	ReasonForMedication pgtype.Text      `json:"reason_for_medication"`
	Status              pgtype.Text      `json:"status"`
	Instructions        pgtype.Text      `json:"instructions"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetPatientMedications(ctx context.Context, arg GetPatientMedicationsParams) ([]GetPatientMedicationsRow, error) {
	rows, err := q.db.Query(ctx, getPatientMedications, arg.PatientID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPatientMedicationsRow
	for rows.Next() {
		var i GetPatientMedicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.MedicationName,
			&i.GenericName,
			&i.Dosage,
			&i.Frequency,
			&i.Route,
			&i.PrescribingDoctor,
			&i.StartDate,
			&i.EndDate,
			&i.ReasonForMedication,
			&i.Status,
			&i.Instructions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatientProfileByID = `-- name: GetPatientProfileByID :one
SELECT id, user_id, first_name, last_name, preferred_name, date_of_birth, gender, preferred_gender_pronouns, primary_address, city, province, postal_code, country, language_preferences, home_language, requires_interpreter, preferred_communication_method, medical_aid_number, medical_aid_provider, has_medical_aid, national_id_number, employment_status, education_level, household_income_range, profile_picture_url, timezone, last_profile_update, referred_by, referral_code, accepts_marketing_emails, created_at, updated_at FROM patient_profiles WHERE id = $1
`

func (q *Queries) GetPatientProfileByID(ctx context.Context, id pgtype.UUID) (PatientProfile, error) {
	row := q.db.QueryRow(ctx, getPatientProfileByID, id)
	var i PatientProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.PreferredName,
		&i.DateOfBirth,
		&i.Gender,
		&i.PreferredGenderPronouns,
		&i.PrimaryAddress,
		&i.City,
		&i.Province,
		&i.PostalCode,
		&i.Country,
		&i.LanguagePreferences,
		&i.HomeLanguage,
		&i.RequiresInterpreter,
		&i.PreferredCommunicationMethod,
		&i.MedicalAidNumber,
		&i.MedicalAidProvider,
		&i.HasMedicalAid,
		&i.NationalIDNumber,
		&i.EmploymentStatus,
		&i.EducationLevel,
		&i.HouseholdIncomeRange,
		&i.ProfilePictureUrl,
		&i.Timezone,
		&i.LastProfileUpdate,
		&i.ReferredBy,
		&i.ReferralCode,
		&i.AcceptsMarketingEmails,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPatientProfileByUserID = `-- name: GetPatientProfileByUserID :one
SELECT id, user_id, first_name, last_name, preferred_name, date_of_birth, 
    gender, preferred_gender_pronouns, primary_address, city, province, 
    postal_code, country, language_preferences, home_language, 
    requires_interpreter, preferred_communication_method, 
    medical_aid_number, medical_aid_provider, has_medical_aid, 
    national_id_number, employment_status, education_level, 
    household_income_range, profile_picture_url, timezone, 
    last_profile_update, referred_by, referral_code, 
    accepts_marketing_emails, created_at, updated_at
FROM patient_profiles
WHERE user_id = $1
`

func (q *Queries) GetPatientProfileByUserID(ctx context.Context, userID pgtype.UUID) (PatientProfile, error) {
	row := q.db.QueryRow(ctx, getPatientProfileByUserID, userID)
	var i PatientProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.PreferredName,
		&i.DateOfBirth,
		&i.Gender,
		&i.PreferredGenderPronouns,
		&i.PrimaryAddress,
		&i.City,
		&i.Province,
		&i.PostalCode,
		&i.Country,
		&i.LanguagePreferences,
		&i.HomeLanguage,
		&i.RequiresInterpreter,
		&i.PreferredCommunicationMethod,
		&i.MedicalAidNumber,
		&i.MedicalAidProvider,
		&i.HasMedicalAid,
		&i.NationalIDNumber,
		&i.EmploymentStatus,
		&i.EducationLevel,
		&i.HouseholdIncomeRange,
		&i.ProfilePictureUrl,
		&i.Timezone,
		&i.LastProfileUpdate,
		&i.ReferredBy,
		&i.ReferralCode,
		&i.AcceptsMarketingEmails,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPrivacyConsent = `-- name: GetPrivacyConsent :one
SELECT id, user_id, health_data_consent, health_data_consent_date, health_data_consent_version, research_consent, research_consent_date, emergency_access_consent, emergency_access_consent_date, sms_communication_consent, email_communication_consent, data_sharing_consent, special_categories_consent, consent_withdrawn, consent_withdrawn_date, withdrawal_reason, ip_address, user_agent, created_at, updated_at FROM privacy_consents WHERE user_id = $1
`

func (q *Queries) GetPrivacyConsent(ctx context.Context, userID pgtype.UUID) (PrivacyConsent, error) {
	row := q.db.QueryRow(ctx, getPrivacyConsent, userID)
	var i PrivacyConsent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.HealthDataConsent,
		&i.HealthDataConsentDate,
		&i.HealthDataConsentVersion,
		&i.ResearchConsent,
		&i.ResearchConsentDate,
		&i.EmergencyAccessConsent,
		&i.EmergencyAccessConsentDate,
		&i.SmsCommunicationConsent,
		&i.EmailCommunicationConsent,
		&i.DataSharingConsent,
		&i.SpecialCategoriesConsent,
		&i.ConsentWithdrawn,
		&i.ConsentWithdrawnDate,
		&i.WithdrawalReason,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSMSConversationByPhone = `-- name: GetSMSConversationByPhone :one
SELECT id, user_id, phone_number, current_menu, conversation_state, last_message_sent, last_message_received, last_interaction_at, last_location, last_search_query, callback_scheduled, created_at, updated_at FROM sms_conversations WHERE phone_number = $1
`

func (q *Queries) GetSMSConversationByPhone(ctx context.Context, phoneNumber string) (SmsConversation, error) {
	row := q.db.QueryRow(ctx, getSMSConversationByPhone, phoneNumber)
	var i SmsConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PhoneNumber,
		&i.CurrentMenu,
		&i.ConversationState,
		&i.LastMessageSent,
		&i.LastMessageReceived,
		&i.LastInteractionAt,
		&i.LastLocation,
		&i.LastSearchQuery,
		&i.CallbackScheduled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, user_id, session_token, device_type, ip_address, 
    user_agent, expires_at, created_at
FROM user_sessions
WHERE session_token = $1 AND expires_at > NOW()
`

type GetSessionRow struct {
	ID           pgtype.UUID      `json:"id"`
	UserID       pgtype.UUID      `json:"user_id"`
	SessionToken string           `json:"session_token"`
	DeviceType   pgtype.Text      `json:"device_type"`
	IpAddress    *netip.Addr      `json:"ip_address"`
	UserAgent    pgtype.Text      `json:"user_agent"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetSession(ctx context.Context, sessionToken string) (GetSessionRow, error) {
	row := q.db.QueryRow(ctx, getSession, sessionToken)
	var i GetSessionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.DeviceType,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getStaffCredentials = `-- name: GetStaffCredentials :many
SELECT id, staff_id, credential_type, credential_number, 
    issuing_authority, issue_date, expiry_date, status,
    verified_by, verification_date, document_url, notes
FROM professional_credentials
WHERE staff_id = $1
ORDER BY issue_date DESC
`

type GetStaffCredentialsRow struct {
	ID               pgtype.UUID      `json:"id"`
	StaffID          pgtype.UUID      `json:"staff_id"`
	CredentialType   string           `json:"credential_type"`
	CredentialNumber pgtype.Text      `json:"credential_number"`
	IssuingAuthority string           `json:"issuing_authority"`
	IssueDate        pgtype.Date      `json:"issue_date"`
	ExpiryDate       pgtype.Date      `json:"expiry_date"`
	Status           pgtype.Text      `json:"status"`
	VerifiedBy       pgtype.UUID      `json:"verified_by"`
	VerificationDate pgtype.Timestamp `json:"verification_date"`
	DocumentUrl      pgtype.Text      `json:"document_url"`
	Notes            pgtype.Text      `json:"notes"`
}

func (q *Queries) GetStaffCredentials(ctx context.Context, staffID pgtype.UUID) ([]GetStaffCredentialsRow, error) {
	rows, err := q.db.Query(ctx, getStaffCredentials, staffID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStaffCredentialsRow
	for rows.Next() {
		var i GetStaffCredentialsRow
		if err := rows.Scan(
			&i.ID,
			&i.StaffID,
			&i.CredentialType,
			&i.CredentialNumber,
			&i.IssuingAuthority,
			&i.IssueDate,
			&i.ExpiryDate,
			&i.Status,
			&i.VerifiedBy,
			&i.VerificationDate,
			&i.DocumentUrl,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingImmunizations = `-- name: GetUpcomingImmunizations :many
SELECT id, patient_id, vaccine_name, vaccine_type, next_due_date,
    dose_number, total_doses
FROM patient_immunizations
WHERE patient_id = $1 
    AND next_due_date IS NOT NULL 
    AND next_due_date > NOW()
ORDER BY next_due_date ASC
`

type GetUpcomingImmunizationsRow struct {
	ID          pgtype.UUID `json:"id"`
	PatientID   pgtype.UUID `json:"patient_id"`
	VaccineName string      `json:"vaccine_name"`
	VaccineType pgtype.Text `json:"vaccine_type"`
	NextDueDate pgtype.Date `json:"next_due_date"`
	DoseNumber  pgtype.Int4 `json:"dose_number"`
	TotalDoses  pgtype.Int4 `json:"total_doses"`
}

func (q *Queries) GetUpcomingImmunizations(ctx context.Context, patientID pgtype.UUID) ([]GetUpcomingImmunizationsRow, error) {
	rows, err := q.db.Query(ctx, getUpcomingImmunizations, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUpcomingImmunizationsRow
	for rows.Next() {
		var i GetUpcomingImmunizationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.VaccineName,
			&i.VaccineType,
			&i.NextDueDate,
			&i.DoseNumber,
			&i.TotalDoses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivities = `-- name: GetUserActivities :many
SELECT id, user_id, activity_type, activity_details, ip_address,
    device_type, resource_type, resource_id, performed_at
FROM user_activities
WHERE user_id = $1
ORDER BY performed_at DESC
LIMIT $2 OFFSET $3
`

type GetUserActivitiesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetUserActivitiesRow struct {
	ID              pgtype.UUID      `json:"id"`
	UserID          pgtype.UUID      `json:"user_id"`
	ActivityType    string           `json:"activity_type"`
	ActivityDetails []byte           `json:"activity_details"`
	IpAddress       *netip.Addr      `json:"ip_address"`
	DeviceType      pgtype.Text      `json:"device_type"`
	ResourceType    pgtype.Text      `json:"resource_type"`
	ResourceID      pgtype.UUID      `json:"resource_id"`
	PerformedAt     pgtype.Timestamp `json:"performed_at"`
}

func (q *Queries) GetUserActivities(ctx context.Context, arg GetUserActivitiesParams) ([]GetUserActivitiesRow, error) {
	rows, err := q.db.Query(ctx, getUserActivities, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserActivitiesRow
	for rows.Next() {
		var i GetUserActivitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ActivityType,
			&i.ActivityDetails,
			&i.IpAddress,
			&i.DeviceType,
			&i.ResourceType,
			&i.ResourceID,
			&i.PerformedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, phone, password_hash, role, status, is_verified, 
    verification_token, verification_expires, last_login, login_count, 
    is_sms_only, sms_consent_given, popia_consent_given, 
    profile_completion_percentage, created_at, updated_at
FROM users
WHERE email = $1 AND status != 'inactive'
`

type GetUserByEmailRow struct {
	ID                          pgtype.UUID      `json:"id"`
	Email                       string           `json:"email"`
	Phone                       pgtype.Text      `json:"phone"`
	PasswordHash                pgtype.Text      `json:"password_hash"`
	Role                        string           `json:"role"`
	Status                      pgtype.Text      `json:"status"`
	IsVerified                  pgtype.Bool      `json:"is_verified"`
	VerificationToken           pgtype.Text      `json:"verification_token"`
	VerificationExpires         pgtype.Timestamp `json:"verification_expires"`
	LastLogin                   pgtype.Timestamp `json:"last_login"`
	LoginCount                  pgtype.Int4      `json:"login_count"`
	IsSmsOnly                   pgtype.Bool      `json:"is_sms_only"`
	SmsConsentGiven             pgtype.Bool      `json:"sms_consent_given"`
	PopiaConsentGiven           pgtype.Bool      `json:"popia_consent_given"`
	ProfileCompletionPercentage pgtype.Int4      `json:"profile_completion_percentage"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
	UpdatedAt                   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.IsVerified,
		&i.VerificationToken,
		&i.VerificationExpires,
		&i.LastLogin,
		&i.LoginCount,
		&i.IsSmsOnly,
		&i.SmsConsentGiven,
		&i.PopiaConsentGiven,
		&i.ProfileCompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, phone, role, status, is_verified, last_login, 
    login_count, is_sms_only, profile_completion_percentage, 
    created_at, updated_at
FROM users
WHERE id = $1 AND status != 'inactive'
`

type GetUserByIDRow struct {
	ID                          pgtype.UUID      `json:"id"`
	Email                       string           `json:"email"`
	Phone                       pgtype.Text      `json:"phone"`
	Role                        string           `json:"role"`
	Status                      pgtype.Text      `json:"status"`
	IsVerified                  pgtype.Bool      `json:"is_verified"`
	LastLogin                   pgtype.Timestamp `json:"last_login"`
	LoginCount                  pgtype.Int4      `json:"login_count"`
	IsSmsOnly                   pgtype.Bool      `json:"is_sms_only"`
	ProfileCompletionPercentage pgtype.Int4      `json:"profile_completion_percentage"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
	UpdatedAt                   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.Role,
		&i.Status,
		&i.IsVerified,
		&i.LastLogin,
		&i.LoginCount,
		&i.IsSmsOnly,
		&i.ProfileCompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByPasswordResetToken = `-- name: GetUserByPasswordResetToken :one
SELECT id, email, phone, password_hash, role, status, is_verified, 
    reset_password_token, reset_password_expires, last_login, login_count, 
    is_sms_only, sms_consent_given, popia_consent_given, 
    profile_completion_percentage, created_at, updated_at
FROM users
WHERE reset_password_token = $1 
    AND reset_password_expires > NOW() 
    AND status != 'inactive'
`

type GetUserByPasswordResetTokenRow struct {
	ID                          pgtype.UUID      `json:"id"`
	Email                       string           `json:"email"`
	Phone                       pgtype.Text      `json:"phone"`
	PasswordHash                pgtype.Text      `json:"password_hash"`
	Role                        string           `json:"role"`
	Status                      pgtype.Text      `json:"status"`
	IsVerified                  pgtype.Bool      `json:"is_verified"`
	ResetPasswordToken          pgtype.Text      `json:"reset_password_token"`
	ResetPasswordExpires        pgtype.Timestamp `json:"reset_password_expires"`
	LastLogin                   pgtype.Timestamp `json:"last_login"`
	LoginCount                  pgtype.Int4      `json:"login_count"`
	IsSmsOnly                   pgtype.Bool      `json:"is_sms_only"`
	SmsConsentGiven             pgtype.Bool      `json:"sms_consent_given"`
	PopiaConsentGiven           pgtype.Bool      `json:"popia_consent_given"`
	ProfileCompletionPercentage pgtype.Int4      `json:"profile_completion_percentage"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
	UpdatedAt                   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetUserByPasswordResetToken(ctx context.Context, resetPasswordToken pgtype.Text) (GetUserByPasswordResetTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserByPasswordResetToken, resetPasswordToken)
	var i GetUserByPasswordResetTokenRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.IsVerified,
		&i.ResetPasswordToken,
		&i.ResetPasswordExpires,
		&i.LastLogin,
		&i.LoginCount,
		&i.IsSmsOnly,
		&i.SmsConsentGiven,
		&i.PopiaConsentGiven,
		&i.ProfileCompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, email, phone, password_hash, role, status, is_verified, 
    last_login, login_count, is_sms_only, sms_consent_given, 
    popia_consent_given, profile_completion_percentage, created_at, updated_at
FROM users
WHERE phone = $1 AND status != 'inactive'
`

type GetUserByPhoneRow struct {
	ID                          pgtype.UUID      `json:"id"`
	Email                       string           `json:"email"`
	Phone                       pgtype.Text      `json:"phone"`
	PasswordHash                pgtype.Text      `json:"password_hash"`
	Role                        string           `json:"role"`
	Status                      pgtype.Text      `json:"status"`
	IsVerified                  pgtype.Bool      `json:"is_verified"`
	LastLogin                   pgtype.Timestamp `json:"last_login"`
	LoginCount                  pgtype.Int4      `json:"login_count"`
	IsSmsOnly                   pgtype.Bool      `json:"is_sms_only"`
	SmsConsentGiven             pgtype.Bool      `json:"sms_consent_given"`
	PopiaConsentGiven           pgtype.Bool      `json:"popia_consent_given"`
	ProfileCompletionPercentage pgtype.Int4      `json:"profile_completion_percentage"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
	UpdatedAt                   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetUserByPhone(ctx context.Context, phone pgtype.Text) (GetUserByPhoneRow, error) {
	row := q.db.QueryRow(ctx, getUserByPhone, phone)
	var i GetUserByPhoneRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.IsVerified,
		&i.LastLogin,
		&i.LoginCount,
		&i.IsSmsOnly,
		&i.SmsConsentGiven,
		&i.PopiaConsentGiven,
		&i.ProfileCompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByPhoneWithHash = `-- name: GetUserByPhoneWithHash :one
SELECT id, email, phone, password_hash, role, status, is_verified, 
    last_login, login_count, is_sms_only, sms_consent_given, 
    popia_consent_given, profile_completion_percentage, 
    created_at, updated_at
FROM users
WHERE phone = $1 AND status != 'inactive'
`

type GetUserByPhoneWithHashRow struct {
	ID                          pgtype.UUID      `json:"id"`
	Email                       string           `json:"email"`
	Phone                       pgtype.Text      `json:"phone"`
	PasswordHash                pgtype.Text      `json:"password_hash"`
	Role                        string           `json:"role"`
	Status                      pgtype.Text      `json:"status"`
	IsVerified                  pgtype.Bool      `json:"is_verified"`
	LastLogin                   pgtype.Timestamp `json:"last_login"`
	LoginCount                  pgtype.Int4      `json:"login_count"`
	IsSmsOnly                   pgtype.Bool      `json:"is_sms_only"`
	SmsConsentGiven             pgtype.Bool      `json:"sms_consent_given"`
	PopiaConsentGiven           pgtype.Bool      `json:"popia_consent_given"`
	ProfileCompletionPercentage pgtype.Int4      `json:"profile_completion_percentage"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
	UpdatedAt                   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetUserByPhoneWithHash(ctx context.Context, phone pgtype.Text) (GetUserByPhoneWithHashRow, error) {
	row := q.db.QueryRow(ctx, getUserByPhoneWithHash, phone)
	var i GetUserByPhoneWithHashRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.IsVerified,
		&i.LastLogin,
		&i.LoginCount,
		&i.IsSmsOnly,
		&i.SmsConsentGiven,
		&i.PopiaConsentGiven,
		&i.ProfileCompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByVerificationToken = `-- name: GetUserByVerificationToken :one
SELECT id, email, phone, password_hash, role, status, is_verified, 
    verification_token, verification_expires, last_login, login_count, 
    is_sms_only, sms_consent_given, popia_consent_given, 
    profile_completion_percentage, created_at, updated_at
FROM users
WHERE verification_token = $1 
    AND verification_expires > NOW() 
    AND status != 'inactive'
`

type GetUserByVerificationTokenRow struct {
	ID                          pgtype.UUID      `json:"id"`
	Email                       string           `json:"email"`
	Phone                       pgtype.Text      `json:"phone"`
	PasswordHash                pgtype.Text      `json:"password_hash"`
	Role                        string           `json:"role"`
	Status                      pgtype.Text      `json:"status"`
	IsVerified                  pgtype.Bool      `json:"is_verified"`
	VerificationToken           pgtype.Text      `json:"verification_token"`
	VerificationExpires         pgtype.Timestamp `json:"verification_expires"`
	LastLogin                   pgtype.Timestamp `json:"last_login"`
	LoginCount                  pgtype.Int4      `json:"login_count"`
	IsSmsOnly                   pgtype.Bool      `json:"is_sms_only"`
	SmsConsentGiven             pgtype.Bool      `json:"sms_consent_given"`
	PopiaConsentGiven           pgtype.Bool      `json:"popia_consent_given"`
	ProfileCompletionPercentage pgtype.Int4      `json:"profile_completion_percentage"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
	UpdatedAt                   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetUserByVerificationToken(ctx context.Context, verificationToken pgtype.Text) (GetUserByVerificationTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserByVerificationToken, verificationToken)
	var i GetUserByVerificationTokenRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.IsVerified,
		&i.VerificationToken,
		&i.VerificationExpires,
		&i.LastLogin,
		&i.LoginCount,
		&i.IsSmsOnly,
		&i.SmsConsentGiven,
		&i.PopiaConsentGiven,
		&i.ProfileCompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listClinicStaff = `-- name: ListClinicStaff :many
SELECT id, clinic_id, user_id, title, first_name, last_name,
    professional_title, specialization, staff_role, 
    employment_status, is_accepting_new_patients, created_at
FROM clinic_staff
WHERE clinic_id = $1 
    AND ($2::VARCHAR IS NULL OR staff_role = $2)
    AND employment_status = 'active'
ORDER BY first_name, last_name
`

type ListClinicStaffParams struct {
	ClinicID pgtype.UUID `json:"clinic_id"`
	Column2  string      `json:"column_2"`
}

type ListClinicStaffRow struct {
	ID                     pgtype.UUID      `json:"id"`
	ClinicID               pgtype.UUID      `json:"clinic_id"`
	UserID                 pgtype.UUID      `json:"user_id"`
	Title                  pgtype.Text      `json:"title"`
	FirstName              string           `json:"first_name"`
	LastName               string           `json:"last_name"`
	ProfessionalTitle      pgtype.Text      `json:"professional_title"`
	Specialization         pgtype.Text      `json:"specialization"`
	StaffRole              string           `json:"staff_role"`
	EmploymentStatus       pgtype.Text      `json:"employment_status"`
	IsAcceptingNewPatients pgtype.Bool      `json:"is_accepting_new_patients"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) ListClinicStaff(ctx context.Context, arg ListClinicStaffParams) ([]ListClinicStaffRow, error) {
	rows, err := q.db.Query(ctx, listClinicStaff, arg.ClinicID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClinicStaffRow
	for rows.Next() {
		var i ListClinicStaffRow
		if err := rows.Scan(
			&i.ID,
			&i.ClinicID,
			&i.UserID,
			&i.Title,
			&i.FirstName,
			&i.LastName,
			&i.ProfessionalTitle,
			&i.Specialization,
			&i.StaffRole,
			&i.EmploymentStatus,
			&i.IsAcceptingNewPatients,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClinics = `-- name: ListClinics :many
SELECT id, clinic_name, clinic_type, city, province, 
    physical_address, primary_phone, email, is_verified,
    verification_status, rating, review_count, created_at
FROM clinics
WHERE 
    ($1::VARCHAR IS NULL OR clinic_type = $1)
    AND ($2::VARCHAR IS NULL OR province = $2)
    AND ($3::VARCHAR IS NULL OR city = $3)
    AND ($4::VARCHAR IS NULL OR verification_status = $4)
ORDER BY rating DESC NULLS LAST, created_at DESC
LIMIT $5 OFFSET $6
`

type ListClinicsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Column4 string `json:"column_4"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type ListClinicsRow struct {
	ID                 pgtype.UUID      `json:"id"`
	ClinicName         string           `json:"clinic_name"`
	ClinicType         string           `json:"clinic_type"`
	City               pgtype.Text      `json:"city"`
	Province           pgtype.Text      `json:"province"`
	PhysicalAddress    string           `json:"physical_address"`
	PrimaryPhone       pgtype.Text      `json:"primary_phone"`
	Email              pgtype.Text      `json:"email"`
	IsVerified         pgtype.Bool      `json:"is_verified"`
	VerificationStatus pgtype.Text      `json:"verification_status"`
	Rating             pgtype.Numeric   `json:"rating"`
	ReviewCount        pgtype.Int4      `json:"review_count"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) ListClinics(ctx context.Context, arg ListClinicsParams) ([]ListClinicsRow, error) {
	rows, err := q.db.Query(ctx, listClinics,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClinicsRow
	for rows.Next() {
		var i ListClinicsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClinicName,
			&i.ClinicType,
			&i.City,
			&i.Province,
			&i.PhysicalAddress,
			&i.PrimaryPhone,
			&i.Email,
			&i.IsVerified,
			&i.VerificationStatus,
			&i.Rating,
			&i.ReviewCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByRole = `-- name: ListUsersByRole :many
SELECT id, email, phone, role, status, is_verified, last_login, 
    profile_completion_percentage, created_at
FROM users
WHERE role = $1 AND status != 'inactive'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsersByRoleParams struct {
	Role   string `json:"role"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListUsersByRoleRow struct {
	ID                          pgtype.UUID      `json:"id"`
	Email                       string           `json:"email"`
	Phone                       pgtype.Text      `json:"phone"`
	Role                        string           `json:"role"`
	Status                      pgtype.Text      `json:"status"`
	IsVerified                  pgtype.Bool      `json:"is_verified"`
	LastLogin                   pgtype.Timestamp `json:"last_login"`
	ProfileCompletionPercentage pgtype.Int4      `json:"profile_completion_percentage"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) ListUsersByRole(ctx context.Context, arg ListUsersByRoleParams) ([]ListUsersByRoleRow, error) {
	rows, err := q.db.Query(ctx, listUsersByRole, arg.Role, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersByRoleRow
	for rows.Next() {
		var i ListUsersByRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Phone,
			&i.Role,
			&i.Status,
			&i.IsVerified,
			&i.LastLogin,
			&i.ProfileCompletionPercentage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logDataAccess = `-- name: LogDataAccess :exec
INSERT INTO data_access_logs (
    accessed_by_user_id, accessed_by_role, accessed_user_id,
    accessed_resource_type, accessed_resource_id, access_type,
    access_reason, is_emergency_access, ip_address, user_agent
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type LogDataAccessParams struct {
	AccessedByUserID     pgtype.UUID `json:"accessed_by_user_id"`
	AccessedByRole       pgtype.Text `json:"accessed_by_role"`
	AccessedUserID       pgtype.UUID `json:"accessed_user_id"`
	AccessedResourceType pgtype.Text `json:"accessed_resource_type"`
	AccessedResourceID   pgtype.UUID `json:"accessed_resource_id"`
	AccessType           pgtype.Text `json:"access_type"`
	AccessReason         pgtype.Text `json:"access_reason"`
	IsEmergencyAccess    pgtype.Bool `json:"is_emergency_access"`
	IpAddress            *netip.Addr `json:"ip_address"`
	UserAgent            pgtype.Text `json:"user_agent"`
}

func (q *Queries) LogDataAccess(ctx context.Context, arg LogDataAccessParams) error {
	_, err := q.db.Exec(ctx, logDataAccess,
		arg.AccessedByUserID,
		arg.AccessedByRole,
		arg.AccessedUserID,
		arg.AccessedResourceType,
		arg.AccessedResourceID,
		arg.AccessType,
		arg.AccessReason,
		arg.IsEmergencyAccess,
		arg.IpAddress,
		arg.UserAgent,
	)
	return err
}

const logSMSMessage = `-- name: LogSMSMessage :one
INSERT INTO sms_messages (
    conversation_id, direction, message_body, twilio_message_id,
    twilio_status, segments, cost, cost_currency
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, conversation_id, direction, created_at
`

type LogSMSMessageParams struct {
	ConversationID  pgtype.UUID    `json:"conversation_id"`
	Direction       string         `json:"direction"`
	MessageBody     string         `json:"message_body"`
	TwilioMessageID pgtype.Text    `json:"twilio_message_id"`
	TwilioStatus    pgtype.Text    `json:"twilio_status"`
	Segments        pgtype.Int4    `json:"segments"`
	Cost            pgtype.Numeric `json:"cost"`
	CostCurrency    pgtype.Text    `json:"cost_currency"`
}

type LogSMSMessageRow struct {
	ID             pgtype.UUID      `json:"id"`
	ConversationID pgtype.UUID      `json:"conversation_id"`
	Direction      string           `json:"direction"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) LogSMSMessage(ctx context.Context, arg LogSMSMessageParams) (LogSMSMessageRow, error) {
	row := q.db.QueryRow(ctx, logSMSMessage,
		arg.ConversationID,
		arg.Direction,
		arg.MessageBody,
		arg.TwilioMessageID,
		arg.TwilioStatus,
		arg.Segments,
		arg.Cost,
		arg.CostCurrency,
	)
	var i LogSMSMessageRow
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.Direction,
		&i.CreatedAt,
	)
	return i, err
}

const logUserActivity = `-- name: LogUserActivity :exec

INSERT INTO user_activities (
    user_id, activity_type, activity_details, ip_address,
    user_agent, device_type, device_id, resource_type, resource_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type LogUserActivityParams struct {
	UserID          pgtype.UUID `json:"user_id"`
	ActivityType    string      `json:"activity_type"`
	ActivityDetails []byte      `json:"activity_details"`
	IpAddress       *netip.Addr `json:"ip_address"`
	UserAgent       pgtype.Text `json:"user_agent"`
	DeviceType      pgtype.Text `json:"device_type"`
	DeviceID        pgtype.Text `json:"device_id"`
	ResourceType    pgtype.Text `json:"resource_type"`
	ResourceID      pgtype.UUID `json:"resource_id"`
}

// ============================================
// Audit Logging Queries (POPIA Compliance)
// ============================================
func (q *Queries) LogUserActivity(ctx context.Context, arg LogUserActivityParams) error {
	_, err := q.db.Exec(ctx, logUserActivity,
		arg.UserID,
		arg.ActivityType,
		arg.ActivityDetails,
		arg.IpAddress,
		arg.UserAgent,
		arg.DeviceType,
		arg.DeviceID,
		arg.ResourceType,
		arg.ResourceID,
	)
	return err
}

const searchClinics = `-- name: SearchClinics :many
SELECT id, clinic_name, clinic_type, city, province, 
    physical_address, primary_phone, rating, review_count
FROM clinics
WHERE 
    clinic_name ILIKE '%' || $1 || '%'
    AND ($2::VARCHAR IS NULL OR province = $2)
    AND ($3::VARCHAR IS NULL OR city = $3)
    AND verification_status = 'verified'
ORDER BY rating DESC NULLS LAST
LIMIT $4 OFFSET $5
`

type SearchClinicsParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Column2 string      `json:"column_2"`
	Column3 string      `json:"column_3"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchClinicsRow struct {
	ID              pgtype.UUID    `json:"id"`
	ClinicName      string         `json:"clinic_name"`
	ClinicType      string         `json:"clinic_type"`
	City            pgtype.Text    `json:"city"`
	Province        pgtype.Text    `json:"province"`
	PhysicalAddress string         `json:"physical_address"`
	PrimaryPhone    pgtype.Text    `json:"primary_phone"`
	Rating          pgtype.Numeric `json:"rating"`
	ReviewCount     pgtype.Int4    `json:"review_count"`
}

func (q *Queries) SearchClinics(ctx context.Context, arg SearchClinicsParams) ([]SearchClinicsRow, error) {
	rows, err := q.db.Query(ctx, searchClinics,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchClinicsRow
	for rows.Next() {
		var i SearchClinicsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClinicName,
			&i.ClinicType,
			&i.City,
			&i.Province,
			&i.PhysicalAddress,
			&i.PrimaryPhone,
			&i.Rating,
			&i.ReviewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchClinicsByLocation = `-- name: SearchClinicsByLocation :many
SELECT id, clinic_name, clinic_type, physical_address, city, 
    province, primary_phone, latitude, longitude, rating,
    -- Calculate distance using Haversine formula (approximate)
    (6371 * acos(
        cos(radians($1)) * cos(radians(latitude)) * 
        cos(radians(longitude) - radians($2)) + 
        sin(radians($1)) * sin(radians(latitude))
    )) AS distance_km
FROM clinics
WHERE 
    latitude IS NOT NULL 
    AND longitude IS NOT NULL
    AND verification_status = 'verified'
    AND (6371 * acos(
        cos(radians($1)) * cos(radians(latitude)) * 
        cos(radians(longitude) - radians($2)) + 
        sin(radians($1)) * sin(radians(latitude))
    )) <= $3
ORDER BY distance_km ASC
`

type SearchClinicsByLocationParams struct {
	Radians   float64        `json:"radians"`
	Radians_2 float64        `json:"radians_2"`
	Latitude  pgtype.Numeric `json:"latitude"`
}

type SearchClinicsByLocationRow struct {
	ID              pgtype.UUID    `json:"id"`
	ClinicName      string         `json:"clinic_name"`
	ClinicType      string         `json:"clinic_type"`
	PhysicalAddress string         `json:"physical_address"`
	City            pgtype.Text    `json:"city"`
	Province        pgtype.Text    `json:"province"`
	PrimaryPhone    pgtype.Text    `json:"primary_phone"`
	Latitude        pgtype.Numeric `json:"latitude"`
	Longitude       pgtype.Numeric `json:"longitude"`
	Rating          pgtype.Numeric `json:"rating"`
	DistanceKm      int32          `json:"distance_km"`
}

func (q *Queries) SearchClinicsByLocation(ctx context.Context, arg SearchClinicsByLocationParams) ([]SearchClinicsByLocationRow, error) {
	rows, err := q.db.Query(ctx, searchClinicsByLocation, arg.Radians, arg.Radians_2, arg.Latitude)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchClinicsByLocationRow
	for rows.Next() {
		var i SearchClinicsByLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.ClinicName,
			&i.ClinicType,
			&i.PhysicalAddress,
			&i.City,
			&i.Province,
			&i.PrimaryPhone,
			&i.Latitude,
			&i.Longitude,
			&i.Rating,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPatients = `-- name: SearchPatients :many
SELECT id, user_id, first_name, last_name, city, province, 
    preferred_communication_method, created_at
FROM patient_profiles
WHERE 
    (first_name ILIKE '%' || $1 || '%' OR last_name ILIKE '%' || $1 || '%')
    AND ($2::VARCHAR IS NULL OR province = $2)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchPatientsParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Column2 string      `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchPatientsRow struct {
	ID                           pgtype.UUID      `json:"id"`
	UserID                       pgtype.UUID      `json:"user_id"`
	FirstName                    string           `json:"first_name"`
	LastName                     string           `json:"last_name"`
	City                         pgtype.Text      `json:"city"`
	Province                     pgtype.Text      `json:"province"`
	PreferredCommunicationMethod pgtype.Text      `json:"preferred_communication_method"`
	CreatedAt                    pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) SearchPatients(ctx context.Context, arg SearchPatientsParams) ([]SearchPatientsRow, error) {
	rows, err := q.db.Query(ctx, searchPatients,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchPatientsRow
	for rows.Next() {
		var i SearchPatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.City,
			&i.Province,
			&i.PreferredCommunicationMethod,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPasswordResetToken = `-- name: SetPasswordResetToken :exec
UPDATE users
SET reset_password_token = $2, reset_password_expires = $3
WHERE id = $1
`

type SetPasswordResetTokenParams struct {
	ID                   pgtype.UUID      `json:"id"`
	ResetPasswordToken   pgtype.Text      `json:"reset_password_token"`
	ResetPasswordExpires pgtype.Timestamp `json:"reset_password_expires"`
}

func (q *Queries) SetPasswordResetToken(ctx context.Context, arg SetPasswordResetTokenParams) error {
	_, err := q.db.Exec(ctx, setPasswordResetToken, arg.ID, arg.ResetPasswordToken, arg.ResetPasswordExpires)
	return err
}

const setVerificationToken = `-- name: SetVerificationToken :exec
UPDATE users
SET verification_token = $2, verification_expires = $3
WHERE id = $1
`

type SetVerificationTokenParams struct {
	ID                  pgtype.UUID      `json:"id"`
	VerificationToken   pgtype.Text      `json:"verification_token"`
	VerificationExpires pgtype.Timestamp `json:"verification_expires"`
}

func (q *Queries) SetVerificationToken(ctx context.Context, arg SetVerificationTokenParams) error {
	_, err := q.db.Exec(ctx, setVerificationToken, arg.ID, arg.VerificationToken, arg.VerificationExpires)
	return err
}

const updateClinic = `-- name: UpdateClinic :exec
UPDATE clinics
SET clinic_name = $2, primary_phone = $3, email = $4, 
    description = $5, operating_hours = $6, services = $7,
    specialties = $8, accepts_medical_aid = $9
WHERE id = $1
`

type UpdateClinicParams struct {
	ID                pgtype.UUID `json:"id"`
	ClinicName        string      `json:"clinic_name"`
	PrimaryPhone      pgtype.Text `json:"primary_phone"`
	Email             pgtype.Text `json:"email"`
	Description       pgtype.Text `json:"description"`
	OperatingHours    []byte      `json:"operating_hours"`
	Services          []byte      `json:"services"`
	Specialties       []byte      `json:"specialties"`
	AcceptsMedicalAid pgtype.Bool `json:"accepts_medical_aid"`
}

func (q *Queries) UpdateClinic(ctx context.Context, arg UpdateClinicParams) error {
	_, err := q.db.Exec(ctx, updateClinic,
		arg.ID,
		arg.ClinicName,
		arg.PrimaryPhone,
		arg.Email,
		arg.Description,
		arg.OperatingHours,
		arg.Services,
		arg.Specialties,
		arg.AcceptsMedicalAid,
	)
	return err
}

const updateClinicService = `-- name: UpdateClinicService :exec
UPDATE clinic_services
SET service_name = $2, description = $3, cost = $4,
    is_active = $5, requires_appointment = $6
WHERE id = $1
`

type UpdateClinicServiceParams struct {
	ID                  pgtype.UUID    `json:"id"`
	ServiceName         string         `json:"service_name"`
	Description         pgtype.Text    `json:"description"`
	Cost                pgtype.Numeric `json:"cost"`
	IsActive            pgtype.Bool    `json:"is_active"`
	RequiresAppointment pgtype.Bool    `json:"requires_appointment"`
}

func (q *Queries) UpdateClinicService(ctx context.Context, arg UpdateClinicServiceParams) error {
	_, err := q.db.Exec(ctx, updateClinicService,
		arg.ID,
		arg.ServiceName,
		arg.Description,
		arg.Cost,
		arg.IsActive,
		arg.RequiresAppointment,
	)
	return err
}

const updateClinicStaff = `-- name: UpdateClinicStaff :exec
UPDATE clinic_staff
SET professional_title = $2, specialization = $3, 
    work_email = $4, work_phone = $5, bio = $6,
    is_accepting_new_patients = $7
WHERE id = $1
`

type UpdateClinicStaffParams struct {
	ID                     pgtype.UUID `json:"id"`
	ProfessionalTitle      pgtype.Text `json:"professional_title"`
	Specialization         pgtype.Text `json:"specialization"`
	WorkEmail              pgtype.Text `json:"work_email"`
	WorkPhone              pgtype.Text `json:"work_phone"`
	Bio                    pgtype.Text `json:"bio"`
	IsAcceptingNewPatients pgtype.Bool `json:"is_accepting_new_patients"`
}

func (q *Queries) UpdateClinicStaff(ctx context.Context, arg UpdateClinicStaffParams) error {
	_, err := q.db.Exec(ctx, updateClinicStaff,
		arg.ID,
		arg.ProfessionalTitle,
		arg.Specialization,
		arg.WorkEmail,
		arg.WorkPhone,
		arg.Bio,
		arg.IsAcceptingNewPatients,
	)
	return err
}

const updateCredential = `-- name: UpdateCredential :exec
UPDATE professional_credentials
SET credential_number = $2, expiry_date = $3, 
    status = $4, notes = $5
WHERE id = $1
`

type UpdateCredentialParams struct {
	ID               pgtype.UUID `json:"id"`
	CredentialNumber pgtype.Text `json:"credential_number"`
	ExpiryDate       pgtype.Date `json:"expiry_date"`
	Status           pgtype.Text `json:"status"`
	Notes            pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateCredential(ctx context.Context, arg UpdateCredentialParams) error {
	_, err := q.db.Exec(ctx, updateCredential,
		arg.ID,
		arg.CredentialNumber,
		arg.ExpiryDate,
		arg.Status,
		arg.Notes,
	)
	return err
}

const updateNotificationPreferences = `-- name: UpdateNotificationPreferences :exec
UPDATE notification_preferences
SET sms_enabled = $2, email_enabled = $3, push_enabled = $4,
    appointment_reminders = $5, health_tips = $6,
    medication_reminders = $7, emergency_alerts = $8
WHERE user_id = $1
`

type UpdateNotificationPreferencesParams struct {
	UserID               pgtype.UUID `json:"user_id"`
	SmsEnabled           pgtype.Bool `json:"sms_enabled"`
	EmailEnabled         pgtype.Bool `json:"email_enabled"`
	PushEnabled          pgtype.Bool `json:"push_enabled"`
	AppointmentReminders pgtype.Bool `json:"appointment_reminders"`
	HealthTips           pgtype.Bool `json:"health_tips"`
	MedicationReminders  pgtype.Bool `json:"medication_reminders"`
	EmergencyAlerts      pgtype.Bool `json:"emergency_alerts"`
}

func (q *Queries) UpdateNotificationPreferences(ctx context.Context, arg UpdateNotificationPreferencesParams) error {
	_, err := q.db.Exec(ctx, updateNotificationPreferences,
		arg.UserID,
		arg.SmsEnabled,
		arg.EmailEnabled,
		arg.PushEnabled,
		arg.AppointmentReminders,
		arg.HealthTips,
		arg.MedicationReminders,
		arg.EmergencyAlerts,
	)
	return err
}

const updatePatientAllergy = `-- name: UpdatePatientAllergy :exec
UPDATE patient_allergies
SET allergy_name = $2, severity = $3, reaction_description = $4,
    last_occurrence_date = $5, status = $6, notes = $7
WHERE id = $1
`

type UpdatePatientAllergyParams struct {
	ID                  pgtype.UUID `json:"id"`
	AllergyName         string      `json:"allergy_name"`
	Severity            string      `json:"severity"`
	ReactionDescription pgtype.Text `json:"reaction_description"`
	LastOccurrenceDate  pgtype.Date `json:"last_occurrence_date"`
	Status              pgtype.Text `json:"status"`
	Notes               pgtype.Text `json:"notes"`
}

func (q *Queries) UpdatePatientAllergy(ctx context.Context, arg UpdatePatientAllergyParams) error {
	_, err := q.db.Exec(ctx, updatePatientAllergy,
		arg.ID,
		arg.AllergyName,
		arg.Severity,
		arg.ReactionDescription,
		arg.LastOccurrenceDate,
		arg.Status,
		arg.Notes,
	)
	return err
}

const updatePatientCondition = `-- name: UpdatePatientCondition :exec
UPDATE patient_conditions
SET condition_name = $2, severity = $3, status = $4, 
    notes = $5, last_flare_up = $6, next_checkup_date = $7
WHERE id = $1
`

type UpdatePatientConditionParams struct {
	ID              pgtype.UUID `json:"id"`
	ConditionName   string      `json:"condition_name"`
	Severity        pgtype.Text `json:"severity"`
	Status          pgtype.Text `json:"status"`
	Notes           pgtype.Text `json:"notes"`
	LastFlareUp     pgtype.Date `json:"last_flare_up"`
	NextCheckupDate pgtype.Date `json:"next_checkup_date"`
}

func (q *Queries) UpdatePatientCondition(ctx context.Context, arg UpdatePatientConditionParams) error {
	_, err := q.db.Exec(ctx, updatePatientCondition,
		arg.ID,
		arg.ConditionName,
		arg.Severity,
		arg.Status,
		arg.Notes,
		arg.LastFlareUp,
		arg.NextCheckupDate,
	)
	return err
}

const updatePatientMedicalInfo = `-- name: UpdatePatientMedicalInfo :exec
UPDATE patient_medical_info
SET blood_type = $2, height_cm = $3, weight_kg = $4, bmi = $5,
    overall_health_status = $6, health_summary = $7, 
    primary_care_physician = $8, primary_clinic_id = $9,
    last_measured_date = $10
WHERE patient_id = $1
`

type UpdatePatientMedicalInfoParams struct {
	PatientID            pgtype.UUID    `json:"patient_id"`
	BloodType            pgtype.Text    `json:"blood_type"`
	HeightCm             pgtype.Numeric `json:"height_cm"`
	WeightKg             pgtype.Numeric `json:"weight_kg"`
	Bmi                  pgtype.Numeric `json:"bmi"`
	OverallHealthStatus  pgtype.Text    `json:"overall_health_status"`
	HealthSummary        pgtype.Text    `json:"health_summary"`
	PrimaryCarePhysician pgtype.Text    `json:"primary_care_physician"`
	PrimaryClinicID      pgtype.UUID    `json:"primary_clinic_id"`
	LastMeasuredDate     pgtype.Date    `json:"last_measured_date"`
}

func (q *Queries) UpdatePatientMedicalInfo(ctx context.Context, arg UpdatePatientMedicalInfoParams) error {
	_, err := q.db.Exec(ctx, updatePatientMedicalInfo,
		arg.PatientID,
		arg.BloodType,
		arg.HeightCm,
		arg.WeightKg,
		arg.Bmi,
		arg.OverallHealthStatus,
		arg.HealthSummary,
		arg.PrimaryCarePhysician,
		arg.PrimaryClinicID,
		arg.LastMeasuredDate,
	)
	return err
}

const updatePatientMedication = `-- name: UpdatePatientMedication :exec
UPDATE patient_medications
SET medication_name = $2, dosage = $3, frequency = $4, 
    route = $5, end_date = $6, status = $7, 
    side_effects = $8, instructions = $9
WHERE id = $1
`

type UpdatePatientMedicationParams struct {
	ID             pgtype.UUID `json:"id"`
	MedicationName string      `json:"medication_name"`
	Dosage         pgtype.Text `json:"dosage"`
	Frequency      pgtype.Text `json:"frequency"`
	Route          pgtype.Text `json:"route"`
	EndDate        pgtype.Date `json:"end_date"`
	Status         pgtype.Text `json:"status"`
	SideEffects    pgtype.Text `json:"side_effects"`
	Instructions   pgtype.Text `json:"instructions"`
}

func (q *Queries) UpdatePatientMedication(ctx context.Context, arg UpdatePatientMedicationParams) error {
	_, err := q.db.Exec(ctx, updatePatientMedication,
		arg.ID,
		arg.MedicationName,
		arg.Dosage,
		arg.Frequency,
		arg.Route,
		arg.EndDate,
		arg.Status,
		arg.SideEffects,
		arg.Instructions,
	)
	return err
}

const updatePatientProfile = `-- name: UpdatePatientProfile :exec
UPDATE patient_profiles
SET first_name = $2, last_name = $3, preferred_name = $4, 
    date_of_birth = $5, gender = $6, primary_address = $7, 
    city = $8, province = $9, postal_code = $10, 
    preferred_communication_method = $11, 
    medical_aid_number = $12, medical_aid_provider = $13, 
    has_medical_aid = $14, employment_status = $15, 
    last_profile_update = NOW()
WHERE id = $1
`

type UpdatePatientProfileParams struct {
	ID                           pgtype.UUID `json:"id"`
	FirstName                    string      `json:"first_name"`
	LastName                     string      `json:"last_name"`
	PreferredName                pgtype.Text `json:"preferred_name"`
	DateOfBirth                  pgtype.Date `json:"date_of_birth"`
	Gender                       pgtype.Text `json:"gender"`
	PrimaryAddress               pgtype.Text `json:"primary_address"`
	City                         pgtype.Text `json:"city"`
	Province                     pgtype.Text `json:"province"`
	PostalCode                   pgtype.Text `json:"postal_code"`
	PreferredCommunicationMethod pgtype.Text `json:"preferred_communication_method"`
	MedicalAidNumber             pgtype.Text `json:"medical_aid_number"`
	MedicalAidProvider           pgtype.Text `json:"medical_aid_provider"`
	HasMedicalAid                pgtype.Bool `json:"has_medical_aid"`
	EmploymentStatus             pgtype.Text `json:"employment_status"`
}

func (q *Queries) UpdatePatientProfile(ctx context.Context, arg UpdatePatientProfileParams) error {
	_, err := q.db.Exec(ctx, updatePatientProfile,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.PreferredName,
		arg.DateOfBirth,
		arg.Gender,
		arg.PrimaryAddress,
		arg.City,
		arg.Province,
		arg.PostalCode,
		arg.PreferredCommunicationMethod,
		arg.MedicalAidNumber,
		arg.MedicalAidProvider,
		arg.HasMedicalAid,
		arg.EmploymentStatus,
	)
	return err
}

const updatePrivacyConsent = `-- name: UpdatePrivacyConsent :exec
UPDATE privacy_consents
SET health_data_consent = $2, research_consent = $3,
    sms_communication_consent = $4, email_communication_consent = $5,
    data_sharing_consent = $6
WHERE user_id = $1
`

type UpdatePrivacyConsentParams struct {
	UserID                    pgtype.UUID `json:"user_id"`
	HealthDataConsent         pgtype.Bool `json:"health_data_consent"`
	ResearchConsent           pgtype.Bool `json:"research_consent"`
	SmsCommunicationConsent   pgtype.Bool `json:"sms_communication_consent"`
	EmailCommunicationConsent pgtype.Bool `json:"email_communication_consent"`
	DataSharingConsent        []byte      `json:"data_sharing_consent"`
}

func (q *Queries) UpdatePrivacyConsent(ctx context.Context, arg UpdatePrivacyConsentParams) error {
	_, err := q.db.Exec(ctx, updatePrivacyConsent,
		arg.UserID,
		arg.HealthDataConsent,
		arg.ResearchConsent,
		arg.SmsCommunicationConsent,
		arg.EmailCommunicationConsent,
		arg.DataSharingConsent,
	)
	return err
}

const updateSMSConversation = `-- name: UpdateSMSConversation :exec
UPDATE sms_conversations
SET current_menu = $2, conversation_state = $3,
    last_message_sent = $4, last_message_received = $5,
    last_interaction_at = NOW()
WHERE id = $1
`

type UpdateSMSConversationParams struct {
	ID                  pgtype.UUID `json:"id"`
	CurrentMenu         pgtype.Text `json:"current_menu"`
	ConversationState   []byte      `json:"conversation_state"`
	LastMessageSent     pgtype.Text `json:"last_message_sent"`
	LastMessageReceived pgtype.Text `json:"last_message_received"`
}

func (q *Queries) UpdateSMSConversation(ctx context.Context, arg UpdateSMSConversationParams) error {
	_, err := q.db.Exec(ctx, updateSMSConversation,
		arg.ID,
		arg.CurrentMenu,
		arg.ConversationState,
		arg.LastMessageSent,
		arg.LastMessageReceived,
	)
	return err
}

const updateSessionToken = `-- name: UpdateSessionToken :exec
UPDATE user_sessions
SET session_token = $2, expires_at = $3
WHERE id = $1
`

type UpdateSessionTokenParams struct {
	ID           pgtype.UUID      `json:"id"`
	SessionToken string           `json:"session_token"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) UpdateSessionToken(ctx context.Context, arg UpdateSessionTokenParams) error {
	_, err := q.db.Exec(ctx, updateSessionToken, arg.ID, arg.SessionToken, arg.ExpiresAt)
	return err
}

const updateStaffStatus = `-- name: UpdateStaffStatus :exec
UPDATE clinic_staff
SET employment_status = $2, end_date = $3
WHERE id = $1
`

type UpdateStaffStatusParams struct {
	ID               pgtype.UUID `json:"id"`
	EmploymentStatus pgtype.Text `json:"employment_status"`
	EndDate          pgtype.Date `json:"end_date"`
}

func (q *Queries) UpdateStaffStatus(ctx context.Context, arg UpdateStaffStatusParams) error {
	_, err := q.db.Exec(ctx, updateStaffStatus, arg.ID, arg.EmploymentStatus, arg.EndDate)
	return err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users
SET last_login = NOW(), login_count = login_count + 1
WHERE id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateUserLastLogin, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $2, reset_password_token = NULL, reset_password_expires = NULL
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserStatus = `-- name: UpdateUserStatus :exec
UPDATE users
SET status = $2
WHERE id = $1
`

type UpdateUserStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) error {
	_, err := q.db.Exec(ctx, updateUserStatus, arg.ID, arg.Status)
	return err
}

const verifyClinic = `-- name: VerifyClinic :exec
UPDATE clinics
SET is_verified = TRUE, verification_status = 'verified',
    verified_by = $2, verification_date = NOW(),
    verification_notes = $3
WHERE id = $1
`

type VerifyClinicParams struct {
	ID                pgtype.UUID `json:"id"`
	VerifiedBy        pgtype.UUID `json:"verified_by"`
	VerificationNotes pgtype.Text `json:"verification_notes"`
}

func (q *Queries) VerifyClinic(ctx context.Context, arg VerifyClinicParams) error {
	_, err := q.db.Exec(ctx, verifyClinic, arg.ID, arg.VerifiedBy, arg.VerificationNotes)
	return err
}

const verifyCredential = `-- name: VerifyCredential :exec
UPDATE professional_credentials
SET status = 'verified', verified_by = $2, verification_date = NOW()
WHERE id = $1
`

type VerifyCredentialParams struct {
	ID         pgtype.UUID `json:"id"`
	VerifiedBy pgtype.UUID `json:"verified_by"`
}

func (q *Queries) VerifyCredential(ctx context.Context, arg VerifyCredentialParams) error {
	_, err := q.db.Exec(ctx, verifyCredential, arg.ID, arg.VerifiedBy)
	return err
}

const verifyUser = `-- name: VerifyUser :exec
UPDATE users
SET is_verified = TRUE, verification_token = NULL, verification_expires = NULL
WHERE id = $1
`

func (q *Queries) VerifyUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, verifyUser, id)
	return err
}

const withdrawConsent = `-- name: WithdrawConsent :exec
UPDATE privacy_consents
SET consent_withdrawn = TRUE, consent_withdrawn_date = NOW(),
    withdrawal_reason = $2
WHERE user_id = $1
`

type WithdrawConsentParams struct {
	UserID           pgtype.UUID `json:"user_id"`
	WithdrawalReason pgtype.Text `json:"withdrawal_reason"`
}

func (q *Queries) WithdrawConsent(ctx context.Context, arg WithdrawConsentParams) error {
	_, err := q.db.Exec(ctx, withdrawConsent, arg.UserID, arg.WithdrawalReason)
	return err
}
